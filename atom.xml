<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>某科学のBLOG</title>
  
  <subtitle>与其感慨路难行，不如马上出发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://a-kali.github.io/"/>
  <updated>2019-12-08T11:34:15.751Z</updated>
  <id>http://a-kali.github.io/</id>
  
  <author>
    <name>Hsaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SENet: Squeeze-and-Excitation Networks</title>
    <link href="http://a-kali.github.io/2019/12/08/SENet-Squeeze-and-Excitation-Networks/"/>
    <id>http://a-kali.github.io/2019/12/08/SENet-Squeeze-and-Excitation-Networks/</id>
    <published>2019-12-08T11:24:08.000Z</published>
    <updated>2019-12-08T11:34:15.751Z</updated>
    
    <content type="html"><![CDATA[<p>卷积：局部区域特征融合（各像素之间的特征 &amp; 通道间的特征）</p><p>SENet网络的创新点在于关注channel之间的关系，希望模型可以自动学习到不同channel特征的重要程度</p><p>（待整理）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;卷积：局部区域特征融合（各像素之间的特征 &amp;amp; 通道间的特征）&lt;/p&gt;
&lt;p&gt;SENet网络的创新点在于关注channel之间的关系，希望模型可以自动学习到不同channel特征的重要程度&lt;/p&gt;
&lt;p&gt;（待整理）&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="论文解读" scheme="http://a-kali.github.io/tags/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="深度学习" scheme="http://a-kali.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://a-kali.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="SENet" scheme="http://a-kali.github.io/tags/SENet/"/>
    
  </entry>
  
  <entry>
    <title>轻量级卷积神经网络综述：从SqueezeNet到EfficientNet</title>
    <link href="http://a-kali.github.io/2019/12/05/%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0%EF%BC%9A%E4%BB%8ESqueezeNet%E5%88%B0EfficientNet/"/>
    <id>http://a-kali.github.io/2019/12/05/轻量级卷积神经网络综述：从SqueezeNet到EfficientNet/</id>
    <published>2019-12-05T10:40:16.000Z</published>
    <updated>2019-12-11T14:02:32.717Z</updated>
    
    <content type="html"><![CDATA[<p>在先前的神经网络发展中，神经网络通常是通过加深、加宽网络结构或重复使用特征图来提高网络的性能。但在网络性能提升的同时，也导致了其对内存、CPU/GPU需求大，推演速度慢，耗电量高等问题，难以运用在实时场景和移动设备中。如自动驾驶车载神经网络运行速度慢就有可能导致事故发生，耗电量高则会导致汽车、手机等移动端续航能力变差，而只有轻量级的神经网络能解决这个问题。下面我将介绍近年来轻量级卷积神经网络的发展。</p><h1 id="1-SqueezeNet"><a href="#1-SqueezeNet" class="headerlink" title="1    SqueezeNet"></a>1    SqueezeNet</h1><p>论文地址：<a href="https://arxiv.org/abs/1602.07360v2" target="_blank" rel="noopener">SqueezeNet:AlexNet-level accuracy with 50x fewer parameters and &lt;1MB model size</a></p><p>SqueezeNet网络的主要亮点在于提出了<strong>Fire Module</strong>来减少参数量。Fire Module 分为两部分：<strong>Squeeze 和 Expand</strong>。Squeeze层通过 1×1 卷积对特征图进行降维，减少参数量，Expand层分别使用 1×1 和 3×3 卷积对降维后的特征图进行处理后concat到一起。比起直接用3×3卷积，这种方法减少了一定的运算量。</p><p><img src="https://i.loli.net/2019/12/05/8TYQwPWMnCU3ok4.png" alt="(R7V7PD.png"></p><p>整个网络由多个Fire Module堆叠而成，很像GoogLeNet。右边两个网络结构参考了ResNet。</p><p><img src="https://i.loli.net/2019/12/05/rW4ugsYPjLUxXVh.png" alt="`YX7Opng"></p><h1 id="2-MobileNet-v1"><a href="#2-MobileNet-v1" class="headerlink" title="2    MobileNet v1"></a>2    MobileNet v1</h1><p>论文地址：<a href="https://arxiv.org/abs/1704.04861" target="_blank" rel="noopener">MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications</a></p><p>MobileNet由谷歌公司提出，主要用于移动和嵌入式视觉应用，其亮点在于采用<strong>深度可分离卷积(Depth-wise Separable Convolution)</strong> 代替传统卷积。</p><h2 id="深度可分离卷积"><a href="#深度可分离卷积" class="headerlink" title="深度可分离卷积"></a>深度可分离卷积</h2><p>深度可分离卷积分为两步：</p><ol><li><strong>Depthwise convolution</strong>：对特征图各个通道进行卷积，每个卷积核只有一个通道且只负责特征图的一个通道。</li><li><strong>Pointwise convolution</strong>：使用1×1卷积将特征图串起来，得到和普通卷积一样的输出。</li></ol><p><img src="https://i.loli.net/2019/12/05/9bdIvHnKpY3XOG8.png" alt="W8I.png"></p><h2 id="运算量对比"><a href="#运算量对比" class="headerlink" title="运算量对比"></a>运算量对比</h2><p>假设输入图像为12×12×3，输出图像为8×8×256。</p><ul><li>Convolution：<ul><li>卷积核大小 5×5×3，卷积核数量 256</li><li>数据量：5×5×3×256 = 19200</li><li>计算量：仅考虑乘法运算，每产生一个输出值就要进行5×5×3次运算，一共要产生8×8×256个输出值，故 5×5×3×256×8×8 = 1228800。</li></ul></li><li>Depthwise Separable Convolution：<ul><li>Depthwise convolution：卷积核大小 5×5×1，卷积核数量 3</li><li>Pointwise convolution：卷积核大小 1×1×3，卷积核数量 256</li><li>数据量：5×5×1×3+1×1×3×256 = 843</li><li>计算量：5×5×1×3×8×8+1×1×3×8×8×256 = 53952</li></ul></li></ul><h2 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h2><p>左边是传统卷积，右边是深度可分离卷积。</p><p><img src="https://i.loli.net/2019/12/05/K2pm9axhdokJOiR.png" alt="FT.png"></p><h2 id="实验结果对比"><a href="#实验结果对比" class="headerlink" title="实验结果对比"></a>实验结果对比</h2><p>可以看到MobileNet在只牺牲了少量精确度的情况下节约了大量的运算量和网络参数。</p><p><img src="https://i.loli.net/2019/12/05/YwsgB2EQ7cxT1XC.png" alt="O.png"></p><h1 id="3-Xception"><a href="#3-Xception" class="headerlink" title="3    Xception"></a>3    Xception</h1><p>论文地址：<a href="https://arxiv.org/abs/1610.02357" target="_blank" rel="noopener">Xception: Deep Learning with Depthwise Separable Convolutions</a></p><p>Xception 借鉴了深度可分离卷积的思想并以此改进了Inception V3。</p><p><img src="https://i.loli.net/2019/12/05/Ht6YxQXpTvRbVA2.png" alt="Fpng"></p><p>图中是一个Xception模块，先用 1×1 卷积改变特征图的通道数，再对输出的每个通道分别进行 3×3 卷积，最后将 3×3 卷积的输出concat到一起。</p><h1 id="4-ShuffleNet-v1"><a href="#4-ShuffleNet-v1" class="headerlink" title="4    ShuffleNet v1"></a>4    ShuffleNet v1</h1><p>论文地址：<a href="https://arxiv.org/abs/1707.01083" target="_blank" rel="noopener">ShuffleNet: An Extremely Efficient Convolutional Neural Network for Mobile Devices</a></p><p>ShuffleNet是由旷视公司提出的轻量级网络，该网络结构主要使用了<strong>分组卷积(group convolution)</strong>和<strong>通道洗牌(channel shuffle)</strong>。</p><p><img src="https://i.loli.net/2019/12/05/tsFGvMo17V6QuIg.png" alt="MBng"></p><p>图a展示了分组卷积，即将通道均等分为多组，分别进行卷积操作（类似于深度可分离卷积）。但这样会导致组之间的信息不流通，对精度造成影响。于是使用通道洗牌的方式，对各组的通道进行交换。</p><p>下图是两种ShuffleNet单元：</p><p><img src="https://i.loli.net/2019/12/05/iNdkjWleXIDqsFK.png" alt="7EYQpng"></p><h1 id="5-MobileNet-v2"><a href="#5-MobileNet-v2" class="headerlink" title="5    MobileNet v2"></a>5    MobileNet v2</h1><p>论文地址：<a href="https://arxiv.org/abs/1801.04381" target="_blank" rel="noopener">MobileNetV2: Inverted Residuals and Linear Bottlenecks</a></p><h2 id="MobileNet-v1-存在问题"><a href="#MobileNet-v1-存在问题" class="headerlink" title="MobileNet v1 存在问题"></a>MobileNet v1 存在问题</h2><p>MobileNet v1 虽然很好地降低了模型运算量，但依然存在如下两个问题：</p><ol><li>MobileNet v1 的结构是类似于 VGG 的堆叠结构，而这种结构比起后来的 ResNet、GoogLeNet 来说性能不高。</li><li>Depthwise Convolution 的潜在问题：论文作者发现，由于<strong>深度残差卷积产生的特征图通道数较少，在 ReLU 的影响下很容易产生较大的信息损耗</strong>（这个故事告诉我们不要在压缩通道后用ReLU）。</li></ol><h2 id="MobileNet-v2-的创新点"><a href="#MobileNet-v2-的创新点" class="headerlink" title="MobileNet v2 的创新点"></a>MobileNet v2 的创新点</h2><p>为了解决 v1 存在的问题，v2 提出了以下改进方法：</p><ol><li><p><strong>Inverted Residual Block</strong>：首先从名字可以看出，这是从传统残差块演化而来的，两者主要的不同在于对 1×1 卷积的运用方式不同。传统的残差块使用 1×1 卷积降低特征图的通道数，减少 3×3 卷积的运算量；而 Inverted Residual Block 则是用 1×1 卷积来提升维度，以便提升网络的准确度。可能作者觉得反正 Depthwise Convolution 运算量也不大，不如就牺牲一丢丢速度来提高一下精度吧。</p><p><img src="https://i.loli.net/2019/12/08/cBeWJVdTSU9t5Eb.png" alt="Q_P`KE8N_V3JY_L``4O6CXS.png"></p></li><li><p><strong>Linear Bottlenecks</strong>：对比 v1 和 v2 的结构可以看出，v2 使用线性函数替换了 v1 模块最后的ReLU6：</p></li></ol><p><img src="https://i.loli.net/2019/12/11/aSftLEykhVcC19I.png" alt="H_T83__0YR5Q6K_Y~V8_M_S.png"></p><h1 id="6-ShuffleNet-v2"><a href="#6-ShuffleNet-v2" class="headerlink" title="6    ShuffleNet v2"></a>6    ShuffleNet v2</h1><p>论文地址：<a href="https://arxiv.org/abs/1807.11164" target="_blank" rel="noopener">ShuffleNet V2: Practical Guidelines for Efficient CNN Architecture Design</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常用于神经网络的设计指导指标使用的是计算复杂度衡量指标：<strong>FLOPs</strong>，而不是更直接的评价指标：<strong>运行速度</strong>(speed)。而作者发现相同FLOPs的网络速度可能差别很大，认为FLOPs并不能作为网络性能的唯一衡量指标。</p><p>造成FLOPs和速度不成比例的原因：</p><ol><li>部分影响速度的原因没有被FLOPs包含在内：<ul><li><strong>内存访问成本</strong>(memory access cost, <strong>MAC</strong>)：这会使得强大的GPU算力受到限制。</li><li><strong>并行度</strong>(degree of parallelism)：在相同FLOPs的情况下，并行度高的网络模型速度远高于低并行度模型。</li></ul></li><li>不同的运行平台会影响FLOPs。比如说新版的CUDNN专门对 3 × 3 卷积运算进行了优化。</li></ol><p>出于这点考虑，作者提出了两点高效结构设计的指导性原则：</p><ol><li>应当使用直接的评价指标（e.g., 速度）而不是间接的（e.g., FLOPs）。</li><li>应当在规定的平台上进行评估。</li></ol><h2 id="高效卷积网络设计准测"><a href="#高效卷积网络设计准测" class="headerlink" title="高效卷积网络设计准测"></a>高效卷积网络设计准测</h2><ul><li><strong>G1: 当输入、输出channels数目相同时，conv计算所需的MAC最低。</strong>以深度可分离卷积(Depth-wise Separable Convolution)为例，其pointwise convlution (i.e., 1×1 conv) 部分占用了其大部分复杂度。设$c_1$，$c_2$为 1 × 1 卷积的输入、输出通道数，$h$和$w$为特征图的高和宽，则FLOPs计算如为 $B=hwc_1c_2$。内存访问操作次数为 $MAC=hw(c_1+c_2)+c_1c_2$。得出下面的不等式，仅当输入输出通道数相同时，MAC最小：<script type="math/tex; mode=display">MAC\geq 2\sqrt{hwB}+\frac{B}{hw}</script></li><li><strong>G2: 过多的分组卷积(Group Convolution)会增大 MAC 开销。</strong>设分组数量为 $g$，从下面公式可以看出随着 $g$ 增加，MAC增加。  ：</li></ul><script type="math/tex; mode=display">MAC=hwc_1+\frac{Bg}{c_1}+\frac{B}{hx}</script><ul><li><strong>G3: 网络碎片化(fragmentation)会减少并发度。</strong>这里的碎片化大概指的是模型的分支数量。比如说 NASNET-A 的分支数就高达13，而 ResNet 的分支数为2或3。作者通过实验证明，分支数量的提升会提高网络的准确率，但也会因降低GPU并行计算能力而影响效率。</li><li><strong>G4: Element-wise 操作的计算量不容忽视。</strong>element-wise包括激活、张量相加、添加偏置等，它们的共同特征就是FLOPS较小但是MAC相对较大。同时作者将 depthwise convolution 操作也算入了element-wise，因为其有着同样高的 MAC/FLOP 比率。</li></ul><p>目前的轻量级网络结构主要是是以FLOPS作为度量标准设计的，而没有考虑以上的几点属性。比如说，ShuffleNet v1使用了过多的分组卷积(与G2违背)、bottleneck-like块(与G1违背)；MobileNet v2使用倒置的bottleneck结构(与G1违背)，同时使用了深度卷积和ReLU在”thick”特征图上(与G4违背)；自动生成结构过多的使用了碎片化结构(与G3违背)</p><h2 id="ShuffleNet-V2-网络结构"><a href="#ShuffleNet-V2-网络结构" class="headerlink" title="ShuffleNet V2 网络结构"></a>ShuffleNet V2 网络结构</h2><p>为了使ShuffleNet更加高效，关键在于保持等宽的出入输出通道，以及使用密集卷积操作而不是过多的分组卷积。</p><p><img src="https://i.loli.net/2019/12/11/3YuOe1yB8zalwjL.png" alt="S9YD9ZB_OHNUS`GHFVS@9D0.png"></p><p>如图，左边两个是 ShuffleNet v1 的模块，右边两个是 ShuffleNet v2 的模块。</p><p>图c是 ShuffleNet v2 的基本模块，其首先将输入的通道随机split成两部分（这是一种变相的分组卷积，不过只分了两个组，遵守了G2和G3），一部分恒等映射到模块尾部，另一部分通过三个输入输出通道数相同的卷积前向传播（遵守了G1），之后使用concat操作（而不是add操作，遵守了G4）将两个分支结合在一起，最后进行通道洗牌(channel shuffle)。</p><p>图d为下采样模块，原理类似，stride=2缩小特征图，没有使用channel split操作，最后两个分支concat到一起使通道数翻倍。</p><p>恒等映射后concat到模块尾部，能使特征得到复用，提高准确度。这种思想来源于DenseNet。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://baijiahao.baidu.com/s?id=1589005428414488177&amp;wfr=spider" target="_blank" rel="noopener">纵览轻量化卷积神经网络：SqueezeNet、MobileNet、ShuffleNet、Xception</a></li><li><a href="https://www.jianshu.com/p/fdd7d7353c55" target="_blank" rel="noopener">SqueezeNet | 轻量级深层神经网络</a></li><li><a href="https://www.greedyai.com/" target="_blank" rel="noopener">贪心学院</a></li><li><a href="https://blog.csdn.net/lk3030/article/details/84847879" target="_blank" rel="noopener">Xception</a></li><li><a href="https://blog.csdn.net/kangdi7547/article/details/81431572" target="_blank" rel="noopener">轻量级模型：MobileNet V2</a></li><li><a href="https://www.jianshu.com/p/71e32918ea0a?utm_source=oschina-app" target="_blank" rel="noopener">精简CNN模型系列之六：ShuffleNet v2</a></li><li><a href="https://blog.csdn.net/u014380165/article/details/81322175" target="_blank" rel="noopener">ShuffleNet v2算法笔记</a></li><li><a href="https://blog.csdn.net/h__ang/article/details/88618089" target="_blank" rel="noopener">ShuffleNet_v2模型解读</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在先前的神经网络发展中，神经网络通常是通过加深、加宽网络结构或重复使用特征图来提高网络的性能。但在网络性能提升的同时，也导致了其对内存、CPU/GPU需求大，推演速度慢，耗电量高等问题，难以运用在实时场景和移动设备中。如自动驾驶车载神经网络运行速度慢就有可能导致事故发生，耗
      
    
    </summary>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="论文解读" scheme="http://a-kali.github.io/tags/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="深度学习" scheme="http://a-kali.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://a-kali.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="轻量级网络" scheme="http://a-kali.github.io/tags/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BD%91%E7%BB%9C/"/>
    
      <category term="SqueezeNet" scheme="http://a-kali.github.io/tags/SqueezeNet/"/>
    
      <category term="MobileNet" scheme="http://a-kali.github.io/tags/MobileNet/"/>
    
      <category term="Xception" scheme="http://a-kali.github.io/tags/Xception/"/>
    
      <category term="ShuffleNet" scheme="http://a-kali.github.io/tags/ShuffleNet/"/>
    
      <category term="EfficientNet" scheme="http://a-kali.github.io/tags/EfficientNet/"/>
    
      <category term="深度可分离卷积" scheme="http://a-kali.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%8F%AF%E5%88%86%E7%A6%BB%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSD: Single-shot detectors</title>
    <link href="http://a-kali.github.io/2019/12/04/SSD-Single-shot-detectors/"/>
    <id>http://a-kali.github.io/2019/12/04/SSD-Single-shot-detectors/</id>
    <published>2019-12-04T08:49:35.000Z</published>
    <updated>2019-12-04T13:00:55.233Z</updated>
    
    <content type="html"><![CDATA[<p>论文地址：<a href="https://arxiv.org/abs/1512.02325" target="_blank" rel="noopener">SSD: Single Shot MultiBox Detector</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文提出了一个基于深度神经网络的<strong>单步(single shot)目标检测器SSD</strong>，其在继承了YOLO单步预测高检测速度的同时，拥有不弱于Faster R-CNN的准确度。</p><h1 id="SSD-网络结构"><a href="#SSD-网络结构" class="headerlink" title="SSD 网络结构"></a>SSD 网络结构</h1><p><img src="https://i.loli.net/2019/12/04/qIhrwjU6uRMV4Nn.png" alt="png"></p><p>从图中可以看出：</p><ul><li>不同于YOLOv1和Faster R-CNN，SSD是一个全卷积网络。</li><li>SSD的预测结果并不完全由最后一层输出，而是由其5个<strong>额外特征层(Extra Feature Layers)</strong>和 VGG16中的一层的输出综合而来。</li><li>由于SSD是个全卷积网络，所以其分类操作也由卷积层进行。上图中横向的直线即是<strong>卷积分类器</strong>，卷积核大小为3×3，channel数量为anchors×(Classes+4)。此处anchors指anchor的数量；classes为类别数，预测值为每个类置信度，这点应该会给后面的NMS作为评判标准；+4就是(x,y,w,h)。</li><li>SSD的输出特征图平均每个像素都有一组anchor，整个网络共生成8732个anchor，远多于YOLO和Faster R-CNN。（这里有个问题，根据上面一条，使用3×3卷积核作为滑动窗口是没法做到每个像素都有anchor的，所以此处应该有padding）</li></ul><p><img src="https://i.loli.net/2019/12/04/To4hNmlKez1CrqV.png" alt="2Bng"></p><h1 id="Hard-negative-mining"><a href="#Hard-negative-mining" class="headerlink" title="Hard negative mining"></a>Hard negative mining</h1><p>检测结果中，未被选为最终结果的样本都是负样本。这导致负样本数量远大于正样本，样本不均衡。作者采用<strong>Hard negative mining</strong>的方式，仅选用被误认为是正样本可能性更大的负样本。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>论文中还提到了损失函数和anchor的选择，但跟其它的目标检测网络差不多，就不再赘述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;论文地址：&lt;a href=&quot;https://arxiv.org/abs/1512.02325&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SSD: Single Shot MultiBox Detector&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="论文解读" scheme="http://a-kali.github.io/tags/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="深度学习" scheme="http://a-kali.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://a-kali.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="目标检测" scheme="http://a-kali.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="SSD" scheme="http://a-kali.github.io/tags/SSD/"/>
    
  </entry>
  
  <entry>
    <title>盘点那些在github上找到的宝藏</title>
    <link href="http://a-kali.github.io/2019/12/04/%E7%9B%98%E7%82%B9%E9%82%A3%E4%BA%9B%E5%9C%A8github%E4%B8%8A%E6%89%BE%E5%88%B0%E7%9A%84%E5%AE%9D%E8%97%8F/"/>
    <id>http://a-kali.github.io/2019/12/04/盘点那些在github上找到的宝藏/</id>
    <published>2019-12-03T16:14:40.000Z</published>
    <updated>2019-12-06T06:09:58.133Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>计算机视觉&amp;深度学习超级Road Map！</strong>：盘点了计算机视觉相关的深度学习技术，涵盖了目标分类、目标检测、目标分割、GAN、轻量级模型、人脸检测、人脸识别、人脸对齐、3DCNN、风格迁移、OCR、姿态检测等方向（没有SLAM、自动驾驶、行人检测、对抗样本）的学习路线和各个模型的概述。CVer必备！项目地址：<a href="https://github.com/weslynn/AlphaTree-graphic-deep-neural-network" target="_blank" rel="noopener">https://github.com/weslynn/AlphaTree-graphic-deep-neural-network</a></li><li><strong>使用Python实现各种算法</strong>：想学算法又不想学C++？重度Python患者的福音，项目地址：<a href="https://github.com/TheAlgorithms/Python" target="_blank" rel="noopener">https://github.com/TheAlgorithms/Python</a></li><li><strong>深度学习500问</strong>：以问答形式对常用的概率知识、线性代数、机器学习、深度学习、计算机视觉等热点问题进行阐述，面试党必备。项目地址：<a href="https://github.com/scutan90/DeepLearning-500-questions" target="_blank" rel="noopener">https://github.com/scutan90/DeepLearning-500-questions</a></li><li><strong>3DCNN-PyTorch</strong>：PyTorch 3D卷积预训练模型。项目地址：<a href="https://github.com/kenshohara/3D-ResNets-PyTorch。附腾讯优图的3D医疗影像预训练模型MedicalNet（未来会出2D），亲测效果不错，项目地址：https://github.com/Tencent/MedicalNet" target="_blank" rel="noopener">https://github.com/kenshohara/3D-ResNets-PyTorch。附腾讯优图的3D医疗影像预训练模型MedicalNet（未来会出2D），亲测效果不错，项目地址：https://github.com/Tencent/MedicalNet</a></li><li><strong>南瓜书</strong>：西瓜书公式推导解析，节约2w根头发。项目地址：<a href="https://github.com/datawhalechina/pumpkin-book" target="_blank" rel="noopener">https://github.com/datawhalechina/pumpkin-book</a></li><li><strong>深度学习面试宝典</strong>：涵盖各大公司ML、CV、NLP、数学、算法、强化学习、SLAM等方向的面试题&amp;解答集合！外加面试技巧和经验！面试党吐血墙裂推荐！项目地址：<a href="https://github.com/amusi/Deep-Learning-Interview-Book/tree/master/docs" target="_blank" rel="noopener">https://github.com/amusi/Deep-Learning-Interview-Book/tree/master/docs</a></li><li><strong>PyTorch预训练模型</strong>：<ul><li>主要backbone汇总：<a href="https://github.com/Cadene/pretrained-models.pytorch，美中不足的是没有EfficientNet。" target="_blank" rel="noopener">https://github.com/Cadene/pretrained-models.pytorch，美中不足的是没有EfficientNet。</a></li><li>EfficientNet：<a href="https://github.com/lukemelas/EfficientNet-PyTorch。这个预训练模型有个缺点，只能单GPU运行，但这不妨碍EfficientNet牛逼。" target="_blank" rel="noopener">https://github.com/lukemelas/EfficientNet-PyTorch。这个预训练模型有个缺点，只能单GPU运行，但这不妨碍EfficientNet牛逼。</a></li><li>语义分割模型：<a href="https://github.com/qubvel/segmentation_models.pytorch。主流语义分割模型，可惜没有DeepLab系列。" target="_blank" rel="noopener">https://github.com/qubvel/segmentation_models.pytorch。主流语义分割模型，可惜没有DeepLab系列。</a></li><li>DeepLab：<a href="https://github.com/jfzhang95/pytorch-deeplab-xception" target="_blank" rel="noopener">https://github.com/jfzhang95/pytorch-deeplab-xception</a></li></ul></li><li><strong>数据增广大全</strong>：涵盖了CV、自然语言、音频方向的各种数据增广图例、调用库和论文。项目地址：<a href="https://github.com/AgaMiko/data-augmentation-review" target="_blank" rel="noopener">https://github.com/AgaMiko/data-augmentation-review</a></li></ul><p>找到其它宝藏的小伙伴可以通过邮箱发给我鸭！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;计算机视觉&amp;amp;深度学习超级Road Map！&lt;/strong&gt;：盘点了计算机视觉相关的深度学习技术，涵盖了目标分类、目标检测、目标分割、GAN、轻量级模型、人脸检测、人脸识别、人脸对齐、3DCNN、风格迁移、OCR、姿态检测等方向（没有SL
      
    
    </summary>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="github" scheme="http://a-kali.github.io/tags/github/"/>
    
      <category term="PyTorch" scheme="http://a-kali.github.io/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>常见的聚类算法(K-Means\GMM\DBSCAN)</title>
    <link href="http://a-kali.github.io/2019/12/02/k-means-%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://a-kali.github.io/2019/12/02/k-means-聚类算法/</id>
    <published>2019-12-02T15:59:48.000Z</published>
    <updated>2019-12-02T17:02:13.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><p>在<strong>无监督学习(unsupervised learning)</strong>中，训练样本的标记信息是未知的，需要·通过一些算法来揭示这些样本数据中的内在性质和规律。无监督学习通常解决的是<strong>聚类(clustering)</strong>问题。</p><p>聚类算法通常将数据集中的样本划分为若干个通常是不相交的子集，每个子集称为一个”簇(cluster)”。而每个簇都包含一定的内在关系或者性质。</p><p>如下图是一个为做标记的样本集，通过它们的分布，我们很容易对上图中的样本做出以下几种划分：</p><p>当需要将其划分为两个簇时，即 k=2 时：</p><p><img src="https://s2.ax1x.com/2019/12/03/QKF1eO.png" alt="QKF1eO.png"></p><p>当需要将其划分为四个簇时，即 k=4 时：</p><p><img src="https://s2.ax1x.com/2019/12/03/QKFalt.png" alt="QKFalt.png"></p><p>而对这些样本进行划分的就是聚类算法。下面我们将介绍几种常见的聚类算法中的算法。</p><h1 id="K-means-算法"><a href="#K-means-算法" class="headerlink" title="K-means 算法"></a>K-means 算法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>k-means算法又名 k 均值算法。其算法思想大致为：<strong>先从样本集中随机选取 k 个样本作为簇中心，并计算所有样本与这 k 个簇中心的距离，对于每一个样本，将其划分到与其距离最近的簇中心所在的簇中，对于新的簇计算各个簇的新的簇中心，根据新的簇中心来重新划分簇。重复上述过程，直到所有样本到其簇中心距离之和达到最小。</strong>在普通K-means算法中，k 值通常凭经验和需求、通过多次尝试来选择；度量距离的方法通常采用<strong>欧氏距离</strong>，其它距离测量方法有曼哈顿距离、切比雪夫距离等，在这里不一一赘述。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>（待更新）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;聚类&quot;&gt;&lt;a href=&quot;#聚类&quot; class=&quot;headerlink&quot; title=&quot;聚类&quot;&gt;&lt;/a&gt;聚类&lt;/h1&gt;&lt;p&gt;在&lt;strong&gt;无监督学习(unsupervised learning)&lt;/strong&gt;中，训练样本的标记信息是未知的，需要·通过一些算
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://a-kali.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="k-means" scheme="http://a-kali.github.io/tags/k-means/"/>
    
      <category term="无监督学习" scheme="http://a-kali.github.io/tags/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="聚类" scheme="http://a-kali.github.io/tags/%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>部分计算机视觉算法面试题解答</title>
    <link href="http://a-kali.github.io/2019/12/02/%E9%83%A8%E5%88%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://a-kali.github.io/2019/12/02/部分计算机视觉算法面试题解答/</id>
    <published>2019-12-01T16:59:03.000Z</published>
    <updated>2019-12-01T17:15:59.062Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Q：Dropout是失活神经元还是失活连接</strong></p><p>A：失活神经元并清除失活神经元周围的连接</p><p><a href="https://imgse.com/i/Qm4Aht" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/02/Qm4Aht.md.png" alt="Qm4Aht.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Q：Dropout是失活神经元还是失活连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：失活神经元并清除失活神经元周围的连接&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/Qm4Aht&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="神经网络" scheme="http://a-kali.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="机器学习" scheme="http://a-kali.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="图像处理" scheme="http://a-kali.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>常见激活函数汇总</title>
    <link href="http://a-kali.github.io/2019/12/01/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/"/>
    <id>http://a-kali.github.io/2019/12/01/激活函数汇总/</id>
    <published>2019-12-01T15:05:09.000Z</published>
    <updated>2019-12-01T16:38:44.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h1><p>Sigmoid 常用于二分类和多标签分类的最后一层，能将实数值映射到0-1之间。</p><p>函数式：<br>$$<br>σ(x) = \frac{1}{1+e^{-x}}<br>$$<br>导数式：<br>$$<br>σ’(x) = σ(x)×(1-σ(x))<br>$$<br>函数图像：</p><p><a href="https://imgse.com/i/QmcKiT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/01/QmcKiT.md.png" alt="QmcKiT.md.png"></a></p><h1 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h1><p>ReLU是神经网络激活层最常用的一种函数，因为其运算简单、易于求导，能用最简单的方式实现非线性运算的性质。</p><p>函数式：<br>$$<br>f(x)=max(0,x)<br>$$<br>函数图像：</p><p><a href="https://imgse.com/i/QmcLkV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/01/QmcLkV.md.png" alt="QmcLkV.md.png"></a></p><h1 id="Tanh"><a href="#Tanh" class="headerlink" title="Tanh"></a>Tanh</h1><p>常见于递归神经网络。</p><p>函数式：<br>$$<br>f(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}<br>$$<br>函数图像：</p><p><img src="https://s2.ax1x.com/2019/12/01/QmgaBn.png" alt="QmgaBn.png"></p><h1 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h1><p>函数式：<br>$$<br>f(x)=\left{<br>\begin{aligned}<br>x, \quad x\geq0\<br>ax, \quad x&lt;0<br>\end{aligned}<br>\right.<br>$$<br>函数图像：</p><p><img src="https://s2.ax1x.com/2019/12/01/Qm21bR.png" alt="Qm21bR.png"></p><h1 id="PReLU"><a href="#PReLU" class="headerlink" title="PReLU"></a>PReLU</h1><p>PReLU(Parametric Rectified Linear Unit) 参数化修正线性单元。其参数随着网络训练而改变。</p><p><img src="https://s2.ax1x.com/2019/12/02/QmRH0A.png" alt="QmRH0A.png"></p><p>参数更新：</p><p><img src="https://s2.ax1x.com/2019/12/02/QmROtP.png" alt="QmROtP.png"></p><h1 id="RReLU"><a href="#RReLU" class="headerlink" title="RReLU"></a>RReLU</h1><p>Random Leaky ReLU，其参数是随机生成的在[0, 1)之间的值。</p><p><img src="https://s2.ax1x.com/2019/12/02/QmWjER.png" alt="QmWjER.png"></p><h1 id="ELU"><a href="#ELU" class="headerlink" title="ELU"></a>ELU</h1><p>指数线性单元。右侧线性部分使得ELU能够缓解梯度消失，而左侧软饱能够让ELU对输入变化或噪声更鲁棒。ELU的输出均值接近于零，所以收敛速度更快。α为常数。</p><p><a href="https://imgse.com/i/Qmf1bj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/02/Qmf1bj.md.png" alt="Qmf1bj.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sigmoid&quot;&gt;&lt;a href=&quot;#Sigmoid&quot; class=&quot;headerlink&quot; title=&quot;Sigmoid&quot;&gt;&lt;/a&gt;Sigmoid&lt;/h1&gt;&lt;p&gt;Sigmoid 常用于二分类和多标签分类的最后一层，能将实数值映射到0-1之间。&lt;/p&gt;
&lt;p&gt;函数
      
    
    </summary>
    
      <category term="神经网络" scheme="http://a-kali.github.io/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="激活函数" scheme="http://a-kali.github.io/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>递归神经网络（RNN）</title>
    <link href="http://a-kali.github.io/2019/12/01/%E9%80%92%E5%BD%92%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88RNN%EF%BC%89/"/>
    <id>http://a-kali.github.io/2019/12/01/递归神经网络（RNN）/</id>
    <published>2019-12-01T14:08:19.000Z</published>
    <updated>2019-12-01T16:57:04.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要递归神经网络？"><a href="#为什么需要递归神经网络？" class="headerlink" title="为什么需要递归神经网络？"></a>为什么需要递归神经网络？</h1><p>在现实生活中，有很多数据是随着时间的变化而变化的，如：股票行情、语音、天气等，而且文本数据也是有顺序的。这类数据统称为序列数据。序列数据通常长短不一，处理这种数据需要一个能够捕获时间的模型，RNN(Recurrent Neural Network)便应运而生。</p><p>（待更新）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么需要递归神经网络？&quot;&gt;&lt;a href=&quot;#为什么需要递归神经网络？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要递归神经网络？&quot;&gt;&lt;/a&gt;为什么需要递归神经网络？&lt;/h1&gt;&lt;p&gt;在现实生活中，有很多数据是随着时间的变化而变化的，如：股票行
      
    
    </summary>
    
    
      <category term="RNN" scheme="http://a-kali.github.io/tags/RNN/"/>
    
      <category term="LSTM" scheme="http://a-kali.github.io/tags/LSTM/"/>
    
      <category term="GRU" scheme="http://a-kali.github.io/tags/GRU/"/>
    
  </entry>
  
  <entry>
    <title>YOLOv1 - YOLOv3</title>
    <link href="http://a-kali.github.io/2019/11/27/YOLOv1-YOLOv3/"/>
    <id>http://a-kali.github.io/2019/11/27/YOLOv1-YOLOv3/</id>
    <published>2019-11-27T09:00:31.000Z</published>
    <updated>2019-12-04T11:54:54.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YOLOv1"><a href="#YOLOv1" class="headerlink" title="YOLOv1"></a>YOLOv1</h1><p>论文地址：<a href="https://arxiv.org/abs/1506.02640" target="_blank" rel="noopener">You Only Look Once: Unified, Real-Time Object Detection</a></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>众所周知，在深度学习目标检测领域有着两个流派，分别是<strong>基于候选区域的R-CNN流派</strong>和<strong>直接回归输出边框的YOLO流派</strong>。R-CNN系列的准确率较高，但即便发展到Faster R-CNN，运算速度也才只有7fps。为了使检测工作更接近实时，作者提出了YOLO结构。</p><p><img src="https://s2.ax1x.com/2019/11/27/QCYCPs.png" alt="QCYCPs.png"></p><h2 id="YOLO-的实现"><a href="#YOLO-的实现" class="headerlink" title="YOLO 的实现"></a>YOLO 的实现</h2><p>（第一次看可能有点复杂，建议拿笔出来边梳理边看）</p><p>YOLO 将输入图像划分为 <strong>S × S 个网格</strong>。如果一个物体的中心点在这个网格中，则该网格负责检测这个物体。每个网格预测 <strong>B 个边框(bounding box)</strong>及其<strong>置信度(confidence)</strong>。其中置信度为<strong>该网格包含目标物体的概率</strong>乘以预测边界框与真实边界框(ground truth)的<strong>交并比(IOU)</strong>，即：<br>$$<br>Confidence=Pr(Object)×IOU^{truth}_{pred}<br>$$<br>也就是说，<strong>当置信度为0时，边框内不含有任何目标物，除此之外置信度都等于交并比</strong>。该置信度只是个预测值，受真实的置信度监督。这点可以从后面的损失函数看出来。</p><p>于是我们得知，每个边框由5个预测值组成，分别为$x,y,w,h,confidence$。</p><p>同时每个网格预测一组 <strong>C 个类别的概率</strong> $Pr(Class_i|Object)$，即输出一组长度为 C 的概率向量。这个概率表示网格含有物体的情况下，各个类别属于该网格的概率。</p><p>经过上述步骤，最终在神经网络末端输出一个$S×S×(B×5+C)$的张量。</p><p><img src="https://s2.ax1x.com/2019/11/27/QCIFr6.png" alt="QCIFr6.png"></p><p>测试时，将置信度和每一类概率相乘<br>$$<br>Score=Pr(Class_i|Object)×Pr(Object)×IOU^{truth}<em>{pred}=Pr(Class_i)×IOU^{truth}</em>{pred}<br>$$<br>得到的Score表示<strong>每一类在每个边框中的置信度(class-specific confidence for each box)</strong>。通过设置阈值筛选出得分高的box，再以的分最高的box为基准进行NMS选出最优结果。</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>如图，在 PASCAL VOC 数据集中，图像输入为 448×448，取 S=7，B=2，一共有20 个类别（C=20），则输出就是 7x7x30 的一个 tensor。</p><p><img src="https://s2.ax1x.com/2019/11/27/QCHg76.png" alt="QCHg76.png"></p><p>可以看出这是一个<strong>彻头彻尾的端到端网络</strong>。看到这里可能会有点震惊，上面讲了那么多复杂的设定到头来居然只是个这么朴素的端到端网络？事实上，上面那么多设定大多都是来源于其巧妙设计的损失函数。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><img src="https://s2.ax1x.com/2019/11/28/QCq2WD.png" alt="QCq2WD.png"></p><p>由于坐标、长宽、置信度的重要性不同，作者给予了他们不同的损失函数和权重。</p><ul><li>重视坐标预测，给这些损失前面赋予更大的权重，取 5。</li><li>对没有 object 的 box 的 confidence loss，赋予较小的损失权重，取 0.5。</li><li>有 object 的 box 的 confidence loss 和类别的 loss 的损失权重取 1。</li><li>对不同大小的边框预测中，相比于大边框，小边框预测偏一点造成的影响更大。而均方误差中对同样的偏移 loss 是一样。为了缓和这个问题，作者用了一个比较取巧的办法，就是将 box 的 width 和 height 取平方根代替原本的 height 和 width。</li></ul><h2 id="YOLO-的缺点"><a href="#YOLO-的缺点" class="headerlink" title="YOLO 的缺点"></a>YOLO 的缺点</h2><ul><li>YOLO对比较密集的、小型的物体（如鸟群）检测效果不佳。因为会有两个同类物体出现在同一个网格中的情况。</li><li>同一类物体出现的新的不常见的长宽比和其他情况时，泛化能力偏弱。</li><li>由于损失函数的问题，定位误差是影响检测效果的主要原因。尤其是大小物体的处理上，还有待加强。</li><li>召回率远低于RCNN系列。</li></ul><h1 id="YOLOv2-amp-YOLO9000"><a href="#YOLOv2-amp-YOLO9000" class="headerlink" title="YOLOv2 &amp; YOLO9000"></a>YOLOv2 &amp; YOLO9000</h1><p>论文地址：<a href="http://arxiv.org/abs/1612.08242" target="_blank" rel="noopener">YOLO9000: Better, Faster, Stronger</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>YOLOv2：在多方面进行改进，在mAP上超过了使用resnet作为backbone的Faster R-CNN 和 SSD，而且速度更快。</li><li>YOLO9000：使用大量分类数据集和检测数据集进行联合训练，能够对9000+类别进行检测。</li></ul><h2 id="Better"><a href="#Better" class="headerlink" title="Better"></a>Better</h2><p>YOLOv2 和 YOLOv1 对比：</p><p><img src="https://s2.ax1x.com/2019/11/29/QA2ryq.png" alt="QA2ryq.png"></p><ul><li><strong>增加了 batch norm</strong>。</li><li><strong>使用高分辨率微调模型</strong>：YOLOv1 采用224×224大小的图片进行预训练，但训练检测模型时使用的是448×448，这一变动对模型性能会产生一定影响。而YOLOv2在常规预训练和进行正式训练之间使用了448×448的分类图像样本进行了微调，缓解了分辨率突然切换造成的影响。</li><li><strong>采用了 Anchor Boxes</strong>：借鉴Faster R-CNN的做法使用了锚框，大幅提高了召回率但mAP轻微下降。</li><li>将图片输入尺寸改为416×416，grid改为13×13，<strong>使grid长宽为奇数</strong>，这样能更有效地预测图片中央的目标物（根据经验，目标物在图片中央的可能性较大）。</li><li><strong>使用 k-means 聚类算法来选择锚框</strong>：手工选择的锚框可能对性能产生影响性能。作者使用k-means对训练集目标框进行聚类，以IOU为距离计算指标，即 $d = 1 - IOU$。在对性能和准确率进行衡量之后，选择了 $k = 5$，得出聚类结果的5个聚类中心作为锚框的最终选择（只取锚框的大小和形状，不取锚框的位置）。</li><li><strong>Direct location prediction</strong>：在RPN中的锚框非常不稳定，其公式如下：</li></ul><p>$$<br>x=(t_x<em>w_a)−x_a\y=(t_y</em>h_a)−y_a<br>$$</p><p>$t_x$和$t_y$为预测值，当$t_x=1$时，预测框相比于原本的锚框将右移一整个锚框的宽度！YOLOv2对这种方法进行了改进：<br>$$<br>b_x=σ(t_x)+c_x\<br>b_y=σ(t_y)+c_y\<br>b_w=p_we^{t_w}\<br>b_h=p_he^{t_h}\<br>Pr(object)<em>IOU(b,object)=σ(t_o)<br>$$<br>$t_x,t_y,t_w,t_h,t_o$为预测值，被Sigmoid函数限制在(0,1)之间。之后再通过下图的一些运算得到最终box。在*</em>限制了预测值大小**的情况下，模型参数会更容易学习。</p><p><img src="https://i.loli.net/2019/12/03/Pb7ZzNEjQhDtS4c.png" alt="RH.png"></p><ul><li><strong>Fine-Grained Features</strong>：为了能在小型目标上获得更好的效果，作者把浅层高分辨率的特征图叠加到深层低分辨率的图上了，但没详细说明，估计跟U-Net差不多吧。</li><li><strong>多尺度训练</strong>：因为YOLOv2是全卷积，所以能用任意大小的图像作为输入。作者使用了{320,352，…，608}大小的图像进行训练以提高模型的泛化性能。</li></ul><h2 id="Faster"><a href="#Faster" class="headerlink" title="Faster"></a>Faster</h2><p>大部分网络使用VGG16作为backbone，但是VGG有点臃肿。作者自定义了<strong>Darknet-19</strong>作为网络的backbone。</p><p><img src="https://i.loli.net/2019/12/03/MAWNrVztIbf3CjJ.png" alt="BPV.png"></p><h2 id="Stronger"><a href="#Stronger" class="headerlink" title="Stronger"></a>Stronger</h2><p>这部分讲了下YOLO9000和WordTree，但没有看懂而且好像不是很重要的亚子，跳了。</p><h1 id="YOLOv3"><a href="#YOLOv3" class="headerlink" title="YOLOv3"></a>YOLOv3</h1><p>待更新</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]<a href="https://blog.csdn.net/woduoxiangfeiya/article/details/80866155" target="_blank" rel="noopener">YOLOv1论文翻译</a></p><p>[2]<a href="https://blog.csdn.net/guleileo/article/details/80581858" target="_blank" rel="noopener">从YOLOv1到YOLOv3，目标检测的进化之路</a></p><p>[3]<a href="https://www.jianshu.com/p/517a1b344a88" target="_blank" rel="noopener">YOLOv2 / YOLO9000 深入理解</a></p><p>[4]<a href="https://www.jianshu.com/p/b02f64e0d44b" target="_blank" rel="noopener">Yolo系列其二：Yolo_v2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;YOLOv1&quot;&gt;&lt;a href=&quot;#YOLOv1&quot; class=&quot;headerlink&quot; title=&quot;YOLOv1&quot;&gt;&lt;/a&gt;YOLOv1&lt;/h1&gt;&lt;p&gt;论文地址：&lt;a href=&quot;https://arxiv.org/abs/1506.02640&quot; target
      
    
    </summary>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="深度学习" scheme="http://a-kali.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://a-kali.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="目标检测" scheme="http://a-kali.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="YOLO" scheme="http://a-kali.github.io/tags/YOLO/"/>
    
  </entry>
  
  <entry>
    <title>深度学习自动驾驶概述</title>
    <link href="http://a-kali.github.io/2019/11/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%A6%82%E8%BF%B0/"/>
    <id>http://a-kali.github.io/2019/11/05/深度学习自动驾驶概述/</id>
    <published>2019-11-05T09:45:08.000Z</published>
    <updated>2019-11-05T09:46:18.720Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标：</strong>使用端到端的深度学习方法，根据车载摄像头的画面来判断如何<strong>打方向盘和踩油门</strong>。</p><p><img src="https://s2.ax1x.com/2019/11/05/MprAb9.png" alt="MprAb9.png"></p><p>参考论文：End to End Learning for Self-Driving Cars</p><p><strong>收集数据：</strong></p><p><img src="https://s2.ax1x.com/2019/11/05/MpBqT1.png" alt="MpBqT1.png"></p><p>汽车人为行驶时，其左中右三个摄像头、方向盘转向、油门、转向灯等数据都会通过其 CAN bus 传入处理器。而如今的汽车中基本都带有上述传感器帮忙训练神经网络；当汽车自动驾驶时，汽车根据中间摄像头传入的数据来操控方向盘等设备。</p><p><img src="https://s2.ax1x.com/2019/11/05/Mpye1K.png" alt="Mpye1K.png"></p><p><strong>自动驾驶模拟器：</strong></p><p><a href="https://imgchr.com/i/Mp6LR0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/05/Mp6LR0.md.png" alt="Mp6LR0.md.png"></a></p><p>看起来很好玩的样子，有空看看源码了解下神经网络输出如何操控这些游戏。</p><p><strong>图像处理：</strong></p><ul><li>亮度调整（适应白天、晚上、阴天、晴天等情景）</li><li>归一化</li><li>图像切割（去除地平线以上和车头部分的无关紧要的数据）</li><li>水平翻转（左转右转）</li><li>数据平衡（欠采样、过采样、给样本少的数据更大权重、合成新数据）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目标：&lt;/strong&gt;使用端到端的深度学习方法，根据车载摄像头的画面来判断如何&lt;strong&gt;打方向盘和踩油门&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/05/MprAb9.png&quot; al
      
    
    </summary>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="深度学习" scheme="http://a-kali.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="自动驾驶" scheme="http://a-kali.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"/>
    
      <category term="概述" scheme="http://a-kali.github.io/tags/%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kaggle days China, Oct 2019</title>
    <link href="http://a-kali.github.io/2019/10/30/Kaggle-days-China-Oct-2019/"/>
    <id>http://a-kali.github.io/2019/10/30/Kaggle-days-China-Oct-2019/</id>
    <published>2019-10-30T12:17:30.000Z</published>
    <updated>2019-11-09T15:52:47.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Winning-competitions-with-deep-learning-skills-–-SeuTao"><a href="#Winning-competitions-with-deep-learning-skills-–-SeuTao" class="headerlink" title="Winning competitions with deep learning skills – SeuTao"></a>Winning competitions with deep learning skills – SeuTao</h1><p><img src="https://s2.ax1x.com/2019/11/09/Mnu7rQ.png" alt="Mnu7rQ.png"></p><h2 id="Prepare-for-a-DL-competition"><a href="#Prepare-for-a-DL-competition" class="headerlink" title="Prepare for a DL competition"></a>Prepare for a DL competition</h2><ul><li>GPUs 是基础&amp;必要条件，但不是获得金牌的决定性条件。有着9块金牌的涛神在2019年也才只有2块1080ti而已。</li><li>多读 paper 是获得 idea 的关键，在很多 paper 中能找到相似问题的解决方案。</li><li>多读别人的代码。</li></ul><h2 id="Five-steps-to-Win-a-DL-competition"><a href="#Five-steps-to-Win-a-DL-competition" class="headerlink" title="Five steps to Win a DL competition"></a>Five steps to Win a DL competition</h2><ul><li>Understand the data</li><li>Build a strong baseline</li><li>Find the tricks</li><li>Ensemble</li><li>Pseudo-labels</li></ul><h3 id="Build-a-strong-baseline"><a href="#Build-a-strong-baseline" class="headerlink" title="Build a strong baseline"></a>Build a strong baseline</h3><ul><li>据涛神的看法，建立一个 <strong>strong baseline</strong> 是整个比赛中最重要的一环。一个高质量的 baseline 可以直接让你拿到<strong>银牌</strong>甚至 top15。可以建立一个高质量的 pipeline 并重复利用。</li><li>不要使用花里胡哨的神经网络架构和损失函数。这里大概可以理解为，baseline应使用简单轻量的神经网络，便于快速训练、调参、尝试 tricks。</li><li><strong>优化器</strong>：动量梯度下降或者 lr(3e-4) Adam优化器。优化器的改变对网络性能提升不大。</li><li><strong>学习率</strong>：可以尝试 warm up 和 余弦退火/cyclic lr</li><li>找到对数据合适的<strong>数据增强</strong>。</li><li>可靠的<strong>本地验证</strong>。在kaggle上提交验证相对麻烦而且有次数限制，而有一个可靠的本地验证就能快速地尝试验证各种 tricks。</li><li><strong>BatchNorm</strong>问题，基线很难高分的一个原因，涉及到神经网络细节。这里没看懂先挂张图：<img src="https://s2.ax1x.com/2019/11/09/Mn3W5j.png" alt="Mn3W5j.png"></li></ul><h3 id="Find-the-tricks"><a href="#Find-the-tricks" class="headerlink" title="Find the tricks"></a>Find the tricks</h3><ul><li>任务型 trick：图片分类trick、目标检测trick等。这些trick需要大量相关论文的积累。</li><li>数据型 trick：这需要你对数据敏锐的分析。数据相关的trick往往是制胜的关键。</li></ul><h3 id="Ensemble"><a href="#Ensemble" class="headerlink" title="Ensemble"></a>Ensemble</h3><p>融合技巧很重要，比如stacking、blending等</p><p><img src="https://s2.ax1x.com/2019/11/09/Mn82y6.png" alt="Mn82y6.png"></p><h3 id="Pseudo-labels"><a href="#Pseudo-labels" class="headerlink" title="Pseudo labels"></a>Pseudo labels</h3><ul><li>易于使用而且几乎在所有的深度学习竞赛中都奏效。</li><li>可以通过测试集或者外部数据来生成伪标签。</li><li>在比赛的最后stage使用——Overfit the LB then create pseudo labels（这个有点难理解）</li><li>注意不要 overfit 伪标签</li></ul><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ul><li>实验效率很重要，总结每一次实验经验，不管是成功还是失败。</li><li>在 kernel only 这种限制测试时间的比赛上，可以使用模型蒸馏、加速。</li><li>找到任务实质相关的论文。</li><li>熟读计算机视觉各个分支的论文，很可能会在之前读过的相关的论文上找到thick。</li></ul><h1 id="Tricks-of-image-classification-–-Jun-Lan"><a href="#Tricks-of-image-classification-–-Jun-Lan" class="headerlink" title="Tricks of image classification – Jun Lan"></a>Tricks of image classification – Jun Lan</h1><ul><li><p>图像分类大致可以分为两种：多类别分类（一个样本属于一个类别） vs 多标签分类（一个样本属于多个类别）</p></li><li><p>找到之前相似的比赛，观察高分solution</p></li><li><p>将数据增强后的图片可视化查看效果，根据任务选择增强方法</p></li><li><p>医疗影像预训练数据：MedicalNet。目前没开源2d数据</p></li><li><p>cycle learning rate：减少调参，更快收敛</p></li><li><p>多类别：交叉熵损失；多标签：二值交叉熵损失</p></li><li><p>mixup：一种数据增强的方法。将两张图片及其标签按一定比例进行融合</p></li><li><p>apex：基于pytorch的低精度运算（32位或16位）。减少显存占用，增加训练速度。pure float可能会导致精度损失和溢出。解决方案：混合精度训练。（设成O1就行了）</p></li><li><p>梯度累加（batch accumulation）：增大batch的方法，（多累积几步再更新梯度？）</p></li><li><p>伪标签：数据少或有大量额外数据且没有标签的情况下</p><ol><li>训练集训练模型</li><li>测试数据</li><li>将置信度较高的数据放入训练集（0.95、0，98）</li><li>再训练</li></ol></li><li><p>数据蒸馏（knowledge distillation）：使用小模型（student）来获取大模型（teacher）中的核心知识</p><ol><li>将数据集分为k折</li><li>k折交叉验证训练teacher model</li><li>预测out-of-fold的标签</li><li>在out-of-fold训练student model</li></ol></li></ul><hr><h1 id="半年5战5金：Kaggle史上最快GrandMaster是如何炼成的"><a href="#半年5战5金：Kaggle史上最快GrandMaster是如何炼成的" class="headerlink" title="半年5战5金：Kaggle史上最快GrandMaster是如何炼成的"></a>半年5战5金：Kaggle史上最快GrandMaster是如何炼成的</h1><p>下面内容跟 kaggle days 没什么关系，是一些很有用的 tricks。整理自网络，有删改，原文地址：<a href="https://zhuanlan.zhihu.com/p/89476481" target="_blank" rel="noopener">Kaggle你问我答【1】——SeuTao</a></p><p>这是 Kaggle 你问我答 (AMA) 的第一期活动，本期请到的嘉宾是 SueTao，他研究生毕业于东南大学，目前是腾讯的一名算法工程师。SueTao 擅长计算机视觉（Computer Vision），半年 5 战 5 金，也许是史上最快的 GrandMaster。截至目前共斩获 9 金 3 银，kaggle 最高排名全球第 10。</p><p>以下是本期活动的问答集锦：</p><p><strong>Q1：如何搭建kaggle data pipeline?</strong></p><p>A1：我目前的比赛还是集中在cv，也做过语音，还有前段时候的PMP，都是DL相关的竞赛。 数据的pipeline其实是可以积累并且优化的。我觉得可以参考一些前人的代码，尤其是蛙神的code。 可以在蛙神的code基础上，慢慢优化跟积累出自己的数据pipeline。 DL数据pipeline中还有个很重要的部分就是数据增强，这块针对不同比赛可能有不同的做法。</p><p><strong>Q2：自己曾经努力拿过银牌，但是觉得金牌好难，特别是solo的情况，请问金牌和银牌的差距在哪里，如何突破？</strong></p><p>A2：我还是从我参与比较多的cv竞赛角度出发哈。首先，如果你是cv新人，在kaggle竞赛上觉得拿金牌很困难，其实是很正常的。目前cv赛基本被cv高手霸榜了。 如果你是已经比较熟悉cv各个方向的模型，那你可能需要一个竞赛好手来给你带路。毕竟竞赛还是有很多套路的。 如果是新人，我的建议是坚持，通过几个cv竞赛来积累对这个方向的认识。了解不同模型不同任务。 我觉得可以参考padue，大家如果看他竞赛的成绩的话，开始他也只是银牌水平，但是从前段时间的protein开始，他现在在cv赛的水平基本就是solo gold了。 deep learning实践的积累还是很重要，一口吃不成胖子。</p><p><strong>Q4：新出的3d object比赛是不是一种趋势，请问涛神对computer vision的发展有什么观察和展望？</strong></p><p>A4：cv的话3d绝对是一个趋势，包括学术界和工业界； sensor的成本越来越低，性能也越来越好；就人脸识别来说，用3d来说安全性和可靠性就更高了。 其实我目前也算是退坑computer vision了，也谈不上对cv有深入的认识。大家从kaggle上cv赛的数量上可以发现，cv对企业的价值还是非常高的。前景是非常好，例如工业检测之类的。</p><p><strong>Q5：怎么判断该改进网络结构还是调学习率？</strong></p><p>A5：学习率和学习策略可能是搭建baseline里面最重要的部分。这块需要在比赛的前期优化到最好，建议使用简单的网络作为baseline，然后仔细优化学习策略。没有提升空间之后再考虑别的方向的优化。</p><p><strong>Q6：是否应该从分类错误的sample中提取灵感继续改进？如果是该怎么做？</strong></p><p>A6：cv最好的一点是可以看图，非常直观。举个例子：比如之前的鲸鱼竞赛，baseline模型的bad case大多是一些姿态较大，分辨率较差的图像。那么我们就可以考虑增加对应的数据增强。效果也很显著。 再举个反面例子：刚刚结束的nips的cellsignal竞赛，是细胞的荧光成像。整个比赛我完全没有看bad case。 因为没有domain知识，图像非自然，很难观察。 但是也不妨碍比赛能拿名次，只看log来调参。</p><p><strong>Q7：请评价cv 各项任务中 state of the art 模型的实用性，有何推荐？</strong></p><p>A7：“试过才有发言权”，这是我做kaggle之后的一个经验。没做kaggle之前，我工作集中在轻量级的模型，对于sota的大模型几乎没有尝试。所以我在竞赛中会尽量去尝试各种sota，最终会有很多有意思的结论。 会发现kaiming的resnet为什么强，unet为什么就是好用。 有些很fancy的模型真的只是过拟合特定的数据集。 我也没有尝试过所有的sota，但是我觉得paper里的内容看看就好，去伪存真，实践出真知。</p><p><strong>Q8：作为一个新人从头开始拿到金牌的最佳策略？比如选择比赛的类型？</strong></p><p>A8：哈哈 因为我cv一把梭，只能给到cv的经验。如果新人想拿金牌的话，最好就是找一个蛙神all in的比赛，step by step follow蛙神！只要比所有人都肝，有足够计算资源，对齐discussion report出来的模型精度，solo gold就有希望！ 其实我第一个比赛TGS就是这么做的。</p><p><strong>Q9：在kaggle学到的东西是否有应用到别的地方？能否举例说明？</strong></p><p>A9：非常多。举个例子：模型集成（ensemble）。可能有些人说模型集成在实际工作中用不了；工作中的场景有效率的要求；在计算资源受限的情况下，3个小模型集成的效果可能远好于1个大模型的效果。 我之前的参与的人脸项目，其实就用了这样的策略，很好用。但是如何去集成，怎么增大模型间diversity，这些技巧大家可以从kaggle上学习。</p><p><strong>Q10：回头看自己的经历，对刚入坑的新人，有什么想提醒的经验和教训？</strong></p><p>A10：教训到没有，做比赛一年感触还是蛮多的，投入越多收获越大吧。希望大家坚持。 真的只有投入去做了，才会有收获。</p><p><strong>Q11：CV比赛假如遇到瓶颈会往哪些方向尝试？</strong></p><p>A11：数据层面绝对是提分收益最大的方向；还是要多看数据，多分析bad case；不看数据就调网络结构是不可取的。 数据层面有些线索之后，可以指导你对模型结构本身做一些改进。另外最重要的：多看paper，paper是idea的来源。</p><p><strong>Q12：一般会用哪种方式平时积累知识？</strong></p><p>A12：过去很长一段时间内，我积累的方式还是来自比赛 通过一个比赛，我可以验证很多paper的方法，实践在工作中无法使用的模型；帮助我深入理解一些数据上和模型上的问题 感觉从我个人而言，比赛和工作相辅相成，给我工作提供了非常好的积累和储备。</p><p><strong>Q13：想知道打比赛的节奏是什么， 比如比赛结束前一个月， 一周， 几天主要干什么？</strong></p><p>A13：基本上最后一周前，最终方案就要定了。考虑最终的集成。</p><p><strong>Q14：有复现比赛top solution的习惯吗？ 有的话是一种怎样的方式呢？</strong></p><p>A14：会看，但是很少会跑。因为一直忙着做新的比赛。其实应该仔细去研究下的。</p><p><strong>Q15：分类比赛中的最后的sub的阈值应该根据什么来选取呢，有什么选取技巧呢？</strong></p><p>A15：我只能说可靠的local validation是最重要的，所有涉及模型选择，调参；其实都需要一个依据，local validation就是这个依据。这样问题就变成如何建立可靠的local validation了。</p><p><strong>Q16：分类比赛中最后的两个sub一般会怎么样选择呢，不同的方案的模型，还是其他？</strong></p><p>A16：这个问题比较好。前期几个比赛的sub一般都是我选的，有幸抽中过金牌。我个人的建议是，差异一定要大，一个激进一个保守。 就dl比赛来说，集成最稳的是weight ave，简单有效，一般来说我会选一个这个； 然后一些存在过拟合风险的方法，但是lb和cv都很可观的方案，我也会选择一个。</p><p><strong>Q17：请问经常看到各位大佬同时参加好几个比赛，还能拿到很好的名次，这是怎么做到的？</strong></p><p>A17：其实kaggle上的top CVer都会有自己积累下来的pipeline。竞赛任务无非是这几种，迅速搭建一个可靠的baseline，对top选手很容易； 看似在做多个竞赛，可能跑的是一套代码。真的要最终比赛冲刺了，会有针对性地去理解数据和优化。</p><p><strong>Q18：图像比赛有什么通用的技巧吗？厉害的选手一次提交就可以进到绿圈，细节处理上有什么独到之处？</strong></p><p>A18：DL调参的细节太多了，需要很长时间的积累。同样的数据+网络，不同人的训练结果可能相差巨大。这是top CVer的核心竞争力 通用技巧的话，paper上带着“bag of tricks”的都需要仔细阅读 bag of tricks for image classification， bag of tricks for object detection。</p><p><strong>Q19：想问下之前说没法做bad case的时候通过log调参是怎么调的， 另外一般bad case怎么样比较好的分析？</strong></p><p>A19：其实很简单: bias-variance trade off，只看log的话，拿捏好这个。 比如nips cellsignal比赛，baseline效果是，training拟合的非常好，test却非常差。其实是一种train test consistency。从1）数据层面；2）网络层面，去分析可能的情况。1）数据层面:数据分布的问题，2）网络层面：batchnorm。针对性地去做实验，确定问题所在，继续观察bias-variance，要得出可靠结论，再进行下一步。</p><p><strong>Q20：我这边自己写了个基于 pytorch 的轮子, 每次基本上能跟上 public kernel 的步伐, 但是就是很难超越. 我估计是训练资源和调参问题. 那么: 调参大部分用已经训练好的模型来调, 还是每次改变参数都重新训练个几天, 哪种方法对 top CVer 比较实际?</strong></p><p>A20：建议解决计算资源问题，保证快速学习，训练资源很重要，其实最优的实验周期我个人感觉在半天。 半天能出一个实验结果最好，中间可以干别的。 结果出得太快也不好，要及时总结和记录实验。</p><p><strong>Q21：之前看到有新闻说模型会用贴纸识别面包机，用肤色识别罪犯的这种过拟合的情况，还有aptos存在模型通过图片尺寸leak发现lable，有没有什么好办法避免这种情况？</strong></p><p>A21：我感觉过拟合问题其实比大家想象的更严重，之前做活体检测基本就是这么个情况，难以范化。 目前的DL还比较‘蠢’，要说办法的话，加数据算不算？</p><p><strong>Q22：问一个技术性问题，碰到一些受阈值影响的metrics时，训练的时候取最好的模型应该依据val-metrics还是val-loss呢？valid的时候如果遍历阈值，可能会极大的影响效率。不同模型/不同epoch，用不同阈值取得的metrics比较，会不会‘不公平’？</strong></p><p>A22：其实我也没有很好的答案。是我的话，最优的val-metrics和val-loss模型我都会存。其实最担心的是优化的loss和metrics不一致。</p><p><strong>Q23：还想问下对warmRestart这类的循环式的scheduler有什么看法？和传统的ReduceLROnPlateau相比有什么优劣？</strong></p><p>A23：最近发现这个真的很好用。如果用step LR的话，很可能下降的位置就不够好。循环的学习策略，我的感受是既不会有太多过拟合，也不需要很仔细调参，基本会有个不错的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Winning-competitions-with-deep-learning-skills-–-SeuTao&quot;&gt;&lt;a href=&quot;#Winning-competitions-with-deep-learning-skills-–-SeuTao&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="深度学习" scheme="http://a-kali.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="kaggle days" scheme="http://a-kali.github.io/tags/kaggle-days/"/>
    
      <category term="kaggle" scheme="http://a-kali.github.io/tags/kaggle/"/>
    
      <category term="图像分类" scheme="http://a-kali.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    
      <category term="比赛技巧" scheme="http://a-kali.github.io/tags/%E6%AF%94%E8%B5%9B%E6%8A%80%E5%B7%A7/"/>
    
      <category term="优化器" scheme="http://a-kali.github.io/tags/%E4%BC%98%E5%8C%96%E5%99%A8/"/>
    
      <category term="学习率" scheme="http://a-kali.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%8E%87/"/>
    
      <category term="数据蒸馏" scheme="http://a-kali.github.io/tags/%E6%95%B0%E6%8D%AE%E8%92%B8%E9%A6%8F/"/>
    
      <category term="伪标签" scheme="http://a-kali.github.io/tags/%E4%BC%AA%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>深度学习语义分割初期（FCN、UNet、SegNet）</title>
    <link href="http://a-kali.github.io/2019/10/26/FCN%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    <id>http://a-kali.github.io/2019/10/26/FCN论文解读/</id>
    <published>2019-10-26T02:06:38.000Z</published>
    <updated>2019-12-04T07:46:45.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FCN"><a href="#FCN" class="headerlink" title="FCN"></a>FCN</h1><p>论文地址：<a href="https://arxiv.org/abs/1411.4038" target="_blank" rel="noopener">Fully Convolutional Networks for Semantic Segmentation</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>原始的 CNN 在图像的分类和定位任务中都获得了不错的成绩，但在分割任务中表现不佳。本文提出了一种<strong>全卷积网络(Fully Convolution Network, FCN)</strong>，通过进行像素级的预测(pixelwise prediction)来实现<strong>语义分割(semantic segmentaion)</strong>。</p><p><a href="https://imgchr.com/i/MUdneI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/15/MUdneI.md.png" alt="MUdneI.md.png"></a></p><p>实现全卷积网络主要基于三种技术：</p><ul><li>全卷积化（Fully Convolutional）</li><li>反卷积（Deconvolution）</li><li>跃层结构（Skip Layer）</li></ul><h2 id="全卷积化"><a href="#全卷积化" class="headerlink" title="全卷积化"></a>全卷积化</h2><p><img src="https://s2.ax1x.com/2019/11/15/MUB4hV.png" alt="MUB4hV.png"></p><p>简单来说就是把传统CNN最后的全连接层换成了卷积层。全卷积在多篇目标检测的论文中都有提到，其能提取出样本的特征图，样本目标区域对应特征图的感兴趣区域所在位置（如上图中的猫对应heatmap中的彩色像素）。</p><h2 id="上采样（Upsampling）"><a href="#上采样（Upsampling）" class="headerlink" title="上采样（Upsampling）"></a>上采样（Upsampling）</h2><p><img src="https://s2.ax1x.com/2019/11/15/MUBJ6e.png" alt="MUBJ6e.png"></p><p>图像(图a)在经过卷积、池化等一系列处理后，得到的特征图(图b)分辨率远小于原图像。这样一来特征图中的像素无法与原图中一一对应，无法对每个像素进行预测。于是需要对特征图进行<strong>上采样</strong>以提高特征图的分辨率。文中对比了三种上采样的方法，最终选择了<strong>反卷积</strong>。</p><h3 id="Deconvolution"><a href="#Deconvolution" class="headerlink" title="Deconvolution"></a>Deconvolution</h3><p>反卷积是文章作者最终采用的方法，下面是两种反卷积的示例，图解起来十分直观：</p><p><img src="https://s2.ax1x.com/2019/11/15/MUBwkt.gif" alt="MUBwkt.gif"></p><p><img src="https://s2.ax1x.com/2019/11/15/MUBBff.gif" alt="MUBBff.gif"></p><p>下面是另一种解释，这样一看好像确实是把卷积的操作反过来了：</p><p><img src="https://s2.ax1x.com/2019/11/15/MUB20s.png" alt="MUB20s.png"></p><h2 id="跃层结构-Skip-Layer"><a href="#跃层结构-Skip-Layer" class="headerlink" title="跃层结构(Skip Layer)"></a>跃层结构(Skip Layer)</h2><p>FCN 通过卷积和反卷积我们基本能定位到目标区域，但是，我们会发现模型前期是通过卷积、池化、非线性激活函数等作用输出了特征权重图像，我们经过反卷积等操作输出的图像实际是很粗糙的，毕竟丢了很多细节。因此我们需要找到一种方式填补丢失的细节数据，所以就有了<strong>跃层结构</strong>。</p><p>跃层结构将浅层的位置信息和深层的语义信息结合起来，得到更佳鲁棒的结果，其过程如图：</p><p><img src="https://s2.ax1x.com/2019/11/15/MUBz9K.png" alt="MUBz9K.png"></p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="https://s2.ax1x.com/2019/11/15/MUDAAI.png" alt="MUDAAI.png"></p><h2 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h2><p>训练过程分为四个阶段，也体现了作者的设计思路，值得研究。</p><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p><img src="https://s2.ax1x.com/2019/11/15/MdWsPg.png" alt="MdWsPg.png"></p><p>使用数据集对模型的分类backbone进行预训练，使卷积层获得提取相应特征的能力。最后两层红色的是全连接层。</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p><img src="https://s2.ax1x.com/2019/11/15/MdW5IU.png" alt="MdW5IU.png"></p><p> <strong>从特征小图（16×16×4096）预测分割小图（16×16×21），之后直接升采样为大图（300×300×21）。</strong>这里输出通道数为21的原因是：采用的PASCAL数据集中有20类，算上背景类一共21类。每个通道预测一类的像素。反卷积（橙色）的步长为32，故该网络被称为<strong>FCN-32s</strong>。</p><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p><img src="https://s2.ax1x.com/2019/11/15/MdosiV.png" alt="MdosiV.png"></p><p>这个阶段上采样分为两次完成（橙色×2）。 在第二次升采样前，把第4个pooling层（绿色）的预测结果（蓝色）通过跃层结构融合进来，提升精确性。 第二次反卷积步长为16，这个网络称为<strong>FCN-16s</strong>。 </p><h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><p><img src="https://s2.ax1x.com/2019/11/15/MdTPSS.png" alt="MdTPSS.png"></p><p>这个阶段和第三阶段差不多，相较多了一次上采样。这大概是最终得出的FCN模型，因为同样的原因被称为<strong>FCN-8s</strong>。</p><p>比较这几个阶段的输出可以看出，跃层结构利用浅层信息辅助逐步升采样，有更精细的结果。 </p><p><img src="https://s2.ax1x.com/2019/11/15/MdTHkq.png" alt="MdTHkq.png"></p><h2 id="FCN-的缺点"><a href="#FCN-的缺点" class="headerlink" title="FCN 的缺点"></a>FCN 的缺点</h2><ol><li>分割的结果不够精细。图像过于模糊或平滑，没有分割出目标图像的细节。</li><li>因为模型是基于CNN改进而来，即便是用卷积替换了全连接，但是依然是独立像素进行分类，没有充分考虑像素与像素之间的关系。</li></ol><h1 id="U-Net"><a href="#U-Net" class="headerlink" title="U-Net"></a>U-Net</h1><p>论文地址：<a href="https://arxiv.org/abs/1505.04597" target="_blank" rel="noopener">U-Net: Convolutional Networks for Biomedical Image Segmentation</a></p><p><strong>U-Net</strong>是医学图像领域十分常用的一种分割网络，因为跟FCN十分相似，就放这里顺便讲了。</p><h2 id="网络结构-1"><a href="#网络结构-1" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="https://s2.ax1x.com/2019/11/18/MyR5wj.png" alt="MyR5wj.png"></p><p>由于整个结构图呈”U”字型，故名”U-Net”。在知道FCN的原理后，从图中可以很明显地看出U-Net的结构和FCN没太大区别。其主要区别于以下几点：</p><ul><li><p>由于Unet的主要目标数据集为医学影像（最开始是细胞图像），只需要对每个像素点进行二值分割（有病/没病），故输出的特征图只有2个channel。(output segmentation: 388×388×2)</p></li><li><p>在上采样部分依然有大量的特征通道，使得网络可以将环境信息向更高的分辨率层传播。下采样和上采样部分几乎是对称的。</p></li><li><p>输入图像尺寸(572×572)和输出图像尺寸(388×388)不一样。这点似乎是为了配合一种名为<strong>overlap-tile</strong>的方法。如下图，使用左图蓝色区域预测右图黄色区域，滑动蓝色区域重复此操作直到预测完整张图片（这种细胞图尺寸通常都很大）。最终会导致最边上的蓝色区域没法预测，对于这部分使用<strong>镜像法(mirroring)</strong>外推。</p><p>注：关于这部分我也不太确定，想要了解详细原理可以去官网看原版的实现代码。</p><p><img src="https://s2.ax1x.com/2019/11/18/MyqBmq.png" alt="MyqBmq.png"></p></li><li><p>浅层特征和深层特征合并时，Unet使用的是拼接方法（图中白色模块，估计是为了保留更多的channel），而FCN使用的是求和。</p></li><li><p>用少量图像训练便能取得不错的效果，这点对医学领域图像数据集较少的特性十分友好。</p></li></ul><h1 id="SegNet"><a href="#SegNet" class="headerlink" title="SegNet"></a>SegNet</h1><p>论文地址：<a href="https://arxiv.org/abs/1511.00561" target="_blank" rel="noopener">SegNet: A Deep Convolutional Encoder-Decoder Architecture for Image Segmentation</a></p><p>说实话这篇文章没啥意思，就概括地科普一下吧。</p><p>首先架构还是和FCN一样，没啥变化，但文中将网络前面提取特征的部分称为<strong>编码器(Encoder)</strong>，后面上采样的部分称为<strong>解码器(Decoder)</strong>。这组词被沿用至今，可能就是在这里提出来的。</p><p><img src="https://i.loli.net/2019/12/04/OTcs6yDtWQJRoup.png" alt="U61.png"></p><p>然后整篇文章的亮点在于：解码器通过使用从相应的编码器接受的<strong>max-pooling索引</strong>来进行非线性上采样。这种方法<strong>减少了所需要训练的参数量，并且改善了边界划分效果</strong>。</p><p><img src="https://i.loli.net/2019/12/04/mPTJNcjrvlVC6qM.png" alt="E5QZ.png"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]<a href="https://blog.csdn.net/fate_fjh/article/details/52882134" target="_blank" rel="noopener">卷积神经网络CNN（1）——图像卷积与反卷积（后卷积，转置卷积）</a></p><p>[2]<a href="https://blog.csdn.net/qq_31347869/article/details/89429211" target="_blank" rel="noopener">【论文笔记】FCN</a></p><p>[3]<a href="http://www.sohu.com/a/270896638_633698" target="_blank" rel="noopener">10分钟看懂全卷积神经网络（ FCN ）：语义分割深度模型先驱 </a></p><p>[4]<a href="https://blog.csdn.net/qq_36269513/article/details/80420363" target="_blank" rel="noopener">FCN的学习及理解（Fully Convolutional Networks for Semantic Segmentation）</a></p><p>[5]<a href="https://blog.csdn.net/qq_37274615/article/details/73251503" target="_blank" rel="noopener">FCN的理解</a></p><p>[6]<a href="https://blog.csdn.net/justpsss/article/details/77170004" target="_blank" rel="noopener">FCN和U-Net</a></p><p>[7]<a href="https://blog.csdn.net/natsuka/article/details/78565229" target="_blank" rel="noopener">U-net翻译</a></p><p>[8]<a href="https://blog.csdn.net/mieleizhi0522/article/details/82025509" target="_blank" rel="noopener">U-net论文解析</a></p><p>[9]<a href="http://tech.ifeng.com/c/7kx5uizAx5u" target="_blank" rel="noopener">一文带你读懂 SegNet（语义分割）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FCN&quot;&gt;&lt;a href=&quot;#FCN&quot; class=&quot;headerlink&quot; title=&quot;FCN&quot;&gt;&lt;/a&gt;FCN&lt;/h1&gt;&lt;p&gt;论文地址：&lt;a href=&quot;https://arxiv.org/abs/1411.4038&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
      <category term="FCN" scheme="http://a-kali.github.io/tags/FCN/"/>
    
      <category term="CNN" scheme="http://a-kali.github.io/tags/CNN/"/>
    
      <category term="U-Net" scheme="http://a-kali.github.io/tags/U-Net/"/>
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="反卷积" scheme="http://a-kali.github.io/tags/%E5%8F%8D%E5%8D%B7%E7%A7%AF/"/>
    
      <category term="论文解读" scheme="http://a-kali.github.io/tags/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="语义分割" scheme="http://a-kali.github.io/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"/>
    
      <category term="深度学习" scheme="http://a-kali.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://a-kali.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>RSNA Intracranial Hemorrhage Detection 比赛记录</title>
    <link href="http://a-kali.github.io/2019/10/16/RSNA-Intracranial-Hemorrhage-Detection-%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"/>
    <id>http://a-kali.github.io/2019/10/16/RSNA-Intracranial-Hemorrhage-Detection-比赛记录/</id>
    <published>2019-10-16T07:24:54.000Z</published>
    <updated>2019-10-30T12:13:00.459Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />    <label for="pass">Please enter the password to read the blog.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      The article has been encrypted, please enter your password to view.&lt;br&gt;
    
    </summary>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="深度学习" scheme="http://a-kali.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Kaggle" scheme="http://a-kali.github.io/tags/Kaggle/"/>
    
      <category term="图片分类" scheme="http://a-kali.github.io/tags/%E5%9B%BE%E7%89%87%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>R-CNN, Fast R-CNN, Faster R-CNN, Mask R-CNN 系列论文解读</title>
    <link href="http://a-kali.github.io/2019/10/10/R-CNN-Fast-R-CNN-Faster-R-CNN-Mask-R-CNN-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    <id>http://a-kali.github.io/2019/10/10/R-CNN-Fast-R-CNN-Faster-R-CNN-Mask-R-CNN-论文解读/</id>
    <published>2019-10-10T09:21:36.000Z</published>
    <updated>2019-12-04T08:46:09.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h1><p>论文地址：<a href="https://arxiv.org/pdf/1311.2524.pdf" target="_blank" rel="noopener">Rich feature hierarchies for accurate object detection and semantic segmentation</a></p><p>发布时间：2014.10.22</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>伴随着AlexNet的横空出世，卷积神经网络开始进入人们的视线，R-CNN便是将卷积神经网络运用于目标检测和语义分割的一个成功典范，其在 VOC 2012 将最佳mAP提高了30%。其成绩对卷积神经网络在目标检测的运用产生了深远的影响。</p><p>但在这之前，需要解决两个主要的问题：</p><ol><li>与图片分类不同，目标检测需要在图片上定位目标的位置。那么如何利用深度的神经网络去做目标的定位？</li><li>如何在一个小规模的数据集上训练能力强劲的网络模型？</li></ol><p>R-CNN全称为Regions with CNN features，其名字来源于其主要使用的两项技术：卷积神经网络（CNN）和<strong>区域推荐</strong>（Region Proposals），而区域推荐正是第一个问题的解决方法。当时已有许多现成的区域推荐算法，本文作者使用的是<strong>选择性搜索(selective search)算法</strong>。</p><h2 id="选择性搜索"><a href="#选择性搜索" class="headerlink" title="选择性搜索"></a>选择性搜索</h2><p><img src="https://s2.ax1x.com/2019/10/25/KwZVHS.png" alt="KwZVHS.png"></p><p>大概就是根据临近颜色的相似度将左边的原图变成像右边由色块组成的图片，然后根据色块选出候选框。这样可以减少对一些不必要的区域进行卷积运算，比如左图左上角那个框。该算法被后续几代网络沿用，直到 Faster R-CNN 使用神经网络进行区域推荐。</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>R-CNN整体过程如下：</p><ol><li>给定一张输入图片，使用selective search从图片中提取 2000 个类别独立的候选区域。</li><li>将每个候选区域缩放到227×227，输入到 CNN中抽取一个固定长度的特征向量。</li><li>使用<strong>各个类别对应的SVM对特征向量进行二分类</strong>，判断该候选区域是否包含该类别，之后对每个类别的窗口进行极大值抑制。</li></ol><p><img src="https://img-blog.csdnimg.cn/20181210155342586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWJsdWU=,size_16,color_FFFFFF,t_70" alt></p><p>对于第二个问题，作者给出的解决方法是：在大型图片分类数据集ILSVRC上预训练卷积神经网络，并微调（fine-tuning）到小型目标检测数据集PASCAL上，这使得mAP上升了8个百分点。</p><p>R-CNN高效的原因：</p><ol><li>所有类别共享CNN参数</li><li>特征维度相对较小</li></ol><h1 id="SPP-Net"><a href="#SPP-Net" class="headerlink" title="SPP-Net"></a>SPP-Net</h1><p>论文地址：<a href="https://arxiv.org/abs/1406.4729" target="_blank" rel="noopener">Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition</a></p><p>发布时间：2015.4.23</p><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>由于 CNN 需要固定大小的输入，在将图片输入到神经网络之前需要对图片进行缩放(warp)或裁剪(crop)。缩放会造成图片几何失真，而裁剪则可能损失部分目标物像素，这将会对图片识别精确度有所影响。</p><p><img src="https://s2.ax1x.com/2019/10/22/K8nKrd.png" alt="K8nKrd.png"></p><p>CNN 只能接收固定尺寸图片的原因是其全连接层节点数目固定，而其卷积层是可以接收不同尺寸的图片的。于是作者设计了用于神经网络中的 <strong>SPP</strong> (spatial pytamid pooling, 空间金字塔池化) 模块，位于卷积层和全连接层之间，用于<strong>接收任意尺寸的图片、提取其特征并产生固定大小的输出</strong>。而且实验表明，训练时使用不同尺寸的输入，可以提高测试精度。</p><h2 id="空间金字塔池化层"><a href="#空间金字塔池化层" class="headerlink" title="空间金字塔池化层"></a>空间金字塔池化层</h2><p><img src="https://s2.ax1x.com/2019/10/22/KGQ98P.png" alt="KGQ98P.png"></p><p>作者将 CNN 中的最后一个池化层用 SPP 替代。如图所示，<strong>SPP 将最后一层卷积层输出的特征图分割成不同尺寸的网格，分别为4×4、2×2、1×1，然后对每个小格进行max pooling，再将池化后的结果连接起来，就能得到（16+4+1）× 256 的固定长度的输出</strong>（这里的256为256个channel）。</p><h2 id="SPP-在目标检测中的应用"><a href="#SPP-在目标检测中的应用" class="headerlink" title="SPP 在目标检测中的应用"></a>SPP 在目标检测中的应用</h2><p>前面提到，R-CNN 在图像中选出2000个候选窗口，并将每个窗口缩放后输入到神经网络中，这样对一张图片反复使用深度卷积网络十分耗时。测试时，特征提取是其主要的时间瓶颈。</p><p>论文中提到，特征图的ROI与原图中的目标物的位置存在一定的映射关系，如下图：</p><p><img src="https://s2.ax1x.com/2019/10/22/KG6IIA.png" alt="KG6IIA.png"></p><p>于是<strong>对于一张图片，只需要提取一次特征，然后将特征图的2000个候选区域输入 SPP 模块就能得到固定长度的表示。由于只需要进行一次卷积操作，节省了大量候选区域通过神经网络的时间。</strong></p><h1 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h1><p>论文地址：<a href="https://arxiv.org/abs/1504.08083" target="_blank" rel="noopener">Fast R-CNN</a></p><p>发布时间：2015.9.27</p><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><p>SPPnet 虽然对R-CNN进行了一些改进，但仍然存在许多问题：</p><ul><li>需要大量产生候选框</li><li>对目标的定位只能靠候选框来粗略定位</li><li>多阶段pipeline，特征提取、模型训练、SVM分类器训练、边框回归要分别进行</li><li>特征图要存在本地磁盘，影响速度</li></ul><p>于是 Fast R-CNN 改进了在目标检测任务中的性能，其优势如下：</p><ul><li>相比 R-CNN、SPPnet 有着更高的 mAP</li><li>单阶段(single-stage)训练，使用多任务损失(multi-task loss)</li><li>训练可以更新网络每一层的参数</li><li>无需使用磁盘缓存特征</li></ul><h2 id="架构细节和模型训练"><a href="#架构细节和模型训练" class="headerlink" title="架构细节和模型训练"></a>架构细节和模型训练</h2><p><img src="https://s2.ax1x.com/2019/10/23/KtoCi6.png" alt="KtoCi6.png"></p><p>从上图直观上来看，Fast R-CNN 与 SPPnet 的结构有两个区别：</p><ol><li>SPP模块被换成了RoI池化层</li><li>网络末端有两个输出，分别用于图像分类和边框回归。分类器被换成了softmax。使用softmax的好处在于不用单独训练一个SVM分类器；缺点在于对于一个候选框最多只能分出一类物体，即使一个候选框包含了多个类别的目标（大概）。</li></ol><p>另外值得一提的是，Fast R-CNN 采用的是固定大小的输入，而不像SPPnet使用任意大小的输入。</p><h3 id="RoI-池化层"><a href="#RoI-池化层" class="headerlink" title="RoI 池化层"></a>RoI 池化层</h3><p>RoI 池化层实质上就是单层的 SPP 模块。其将一个候选窗口划分为 H×W 的网格，对每个网格内进行最大池化，最后输出一个长度为 H×W 的特征。超参数 H 和 W 视具体网络结构而定。</p><h3 id="多任务损失"><a href="#多任务损失" class="headerlink" title="多任务损失"></a>多任务损失</h3><p>多任务损失由分类任务损失和边框回归任务损失线性组合而成：<br>$$<br>L=L_{cls}(p,u)+\lambda [u\geq 1]L_{loc}(t^u,v)\<br>$$<br>其中：<br>$$<br>L_{cls}(p,u)=-\log p_u\<br>L_{loc}(t^u,v)=\sum smooth_{L_1}(t^u_i-v_i)<br>$$</p><h3 id="Mini-batch-sampling"><a href="#Mini-batch-sampling" class="headerlink" title="Mini-batch sampling"></a>Mini-batch sampling</h3><p>（其实这一段我没看太懂，以下仅作参考）</p><p>在调优(fine tuning)训练时，每个mini-batch中首先加入 N 张完整图片，从 N 张图片中选出一共 R 个 IoU&gt;0.5 的候选区域，然后将这 R 个候选区域作为训练样本放入网络训练。</p><h1 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h1><p>论文地址：<a href="https://arxiv.org/abs/1506.01497" target="_blank" rel="noopener">Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks</a></p><p>发布时间：2016.1.6</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>性能优越的目标检测网络都依赖区域推荐(region proposal)算法来假定目标位置，比如R-CNN中的选择搜索(search selective)算法，而这些区域推荐的计算消耗正是整个网络性能的瓶颈。本文作者引入了<strong>区域推荐网络(Region Proposal Network, RPN)</strong>，尝试使用神经网络来进行区域提取。并将 RPN 和 Fast R-CNN 融合在一起，共享卷积特征，成为一个端到端的神经网络。</p><h2 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h2><p><img src="https://s2.ax1x.com/2019/10/25/KdqldS.png" alt="KdqldS.png"></p><p>Fast R-CNN 大致结构如图。可以看出，网络由四步组成：</p><ol><li>输入的图片经过卷积层输出一张特征图</li><li>将特征图输入 RPN，得到候选区域</li><li>将特征图上候选区域的对应位置输入到 RoI 池化层</li><li>输入到分类器得出分类结果</li></ol><p>那么 RPN 具体是怎样的呢？</p><h2 id="RPN"><a href="#RPN" class="headerlink" title="RPN"></a>RPN</h2><p><img src="https://s2.ax1x.com/2019/10/25/KdIwZQ.png" alt="KdIwZQ.png"></p><p>从上图中可以看到Faster R-CNN更具体的结构，包括左下方的RPN模块。RPN具体流程如下：</p><ol><li><p>使用<strong>滑动窗口(slide window)</strong>遍历整个特征图(feature map)，遍历过程中以每个window中心产生9个预设<strong>锚框(anchor)</strong>，9个锚框分别对应3种尺寸和3种长宽比。</p><p><img src="https://s2.ax1x.com/2019/10/25/KwJZQS.png" alt="KwJZQS.png"></p></li><li><p>将锚框分别输入到<strong>线性分类层(cls layer)</strong>和<strong>边框回归层(reg layer)</strong>中。分类层通过softmax对锚框进行二分类，初步判断该锚框是前景还是背景（锚框里是否包含目标物）；回归层通过边框回归进一步修正锚框，使锚框定位更精确。</p><p><img src="https://s2.ax1x.com/2019/10/26/K0RaZ9.png" alt="K0RaZ9.png"></p></li><li><p>将筛选、修正后的锚框映射到特征图上，输入到ROI池化层。后续操作和Fast R-CNN一样。</p></li></ol><h2 id="Faster-R-CNN-的训练步骤"><a href="#Faster-R-CNN-的训练步骤" class="headerlink" title="Faster R-CNN 的训练步骤"></a>Faster R-CNN 的训练步骤</h2><ol><li>训练一个用于分类的 CNN（用于特征提取）</li><li>使用 CNN 的特征图作为输出，端到端的fine-tune RPN + CNN。IoU&gt;0.7的作为正样本，IoU&lt;0.3的为负样本。</li><li>固定RPN的权值，训练整个网络。</li><li>固定其余部分的权值，训练RPN</li><li>固定CNN、RPN，训练其余部分</li><li>重复步骤4、5直到满意为止</li></ol><p>由于Faster R-CNN的训练步骤过于繁杂，促使了后续的SSD网络对其进行改进。</p><h2 id="R-CNN-家族的总结"><a href="#R-CNN-家族的总结" class="headerlink" title="R-CNN 家族的总结"></a>R-CNN 家族的总结</h2><p><img src="https://i.loli.net/2019/12/04/4kIh9YJQwTuZvEX.png" alt="57KD5.png"></p><p>图源：贪心学院</p><h1 id="Mask-R-CNN"><a href="#Mask-R-CNN" class="headerlink" title="Mask R-CNN"></a>Mask R-CNN</h1><p>（待更新）</p><h1 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h1><p><strong>Q：讲下faster-rcnn？Faster-rcnn里面的NMS的算法原理是什么？</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;R-CNN&quot;&gt;&lt;a href=&quot;#R-CNN&quot; class=&quot;headerlink&quot; title=&quot;R-CNN&quot;&gt;&lt;/a&gt;R-CNN&lt;/h1&gt;&lt;p&gt;论文地址：&lt;a href=&quot;https://arxiv.org/pdf/1311.2524.pdf&quot; target=
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="论文解读" scheme="http://a-kali.github.io/tags/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="深度学习" scheme="http://a-kali.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://a-kali.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="R-CNN" scheme="http://a-kali.github.io/tags/R-CNN/"/>
    
  </entry>
  
  <entry>
    <title>计算机视觉算法岗面试归纳（持续解答ing）</title>
    <link href="http://a-kali.github.io/2019/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%AE%97%E6%B3%95%E5%B2%97%E9%9D%A2%E8%AF%95%E5%BD%92%E7%BA%B3/"/>
    <id>http://a-kali.github.io/2019/10/05/计算机视觉算法岗面试归纳/</id>
    <published>2019-10-05T01:32:59.000Z</published>
    <updated>2019-12-02T17:22:09.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ML"><a href="#ML" class="headerlink" title="ML"></a>ML</h1><ul><li>介绍一下调参的经验</li><li>Softmax的公式和伪代码</li><li>分类常见的指标有什么，如何理解AUC？</li><li>介绍决策树、RF、XGBoost、GBDT和 LightGBM</li><li>XGboost的loss函数的推导（mse以及非mse形式），以及求解推导。</li><li>使用O(N)复杂度完成GBDT分裂</li><li>介绍 F1-score，AUC，交叉熵，ROC</li><li>介绍 Adboost，GBDT，XGBoost</li><li>介绍不同的聚类算法：K-Means、GMM、DBSCAN等</li><li>CCA和PCA的区别</li><li>牛顿法能用于非凸函数吗？</li><li>XGBoost里处理缺失值的方法</li><li>样本不平衡对 SVM 的影响</li><li>KNN和Kmeans的算法中K的含义，K对算法的影响，怎么选择K</li><li>LR的全过程，从train到inference，损失函数</li><li>介绍常见的集成方法</li><li>LR + softmax做多分类和LR + multiLoss 做多分类区别在哪里</li><li>LR为什么用交叉熵作为loss函数</li><li>Kmeans的缺点？如何改善？</li><li><a href="https://a-kali.github.io/2019/12/02/k-means-聚类算法/">讲一下K-means算法的过程以及原理</a></li><li>为什么Bagging降方差，Boosting降偏差？</li><li>介绍XGBoost对GBDT的提升，LightGBM对XGBoost的提升</li><li>为什么要对连续型数值进行离散化，这样做有什么优势</li><li>LR 为什么用sigmoid函数？</li><li>怎么解决样本不均衡（重点考核损失函数优化）</li><li>HMM 和 CRF的区别</li><li>XGBoost 如何处理缺失数据？</li><li>写一下 LR 和 SVM 的损失函数</li><li>正负样本不均衡时的解决方案</li><li>知道哪些降维的方法，具体讲讲</li><li>线性模型和非线性模型都有哪些？</li><li>手写AUC的计算（小矩形积分得到总面积即可）</li><li>决策树分支的原理</li><li>offerpolicy 和 onpolicy 的区别</li><li>为什么随机森林的树比 GBDT 的深一点？</li><li>逻辑回归的目标函数(损失函数)是凸函数吗？</li><li>完全二叉树的概念</li><li>朴素贝叶斯与贝叶斯有什么区别？</li><li>SVM 为什么变成对偶问题来求解？</li><li>缺失值如何处理，什么情况下均值、众数，什么情况下丢弃特征。</li><li>诸如ID类的特征如何处理，编码方式one-hot还是其他的，高维时？什么样才算高维，有没有界定？</li><li>聚类的算法有哪些？评价方法？优化算法？</li><li>解释几何间隔和函数间隔</li><li>描述决策树，如何选特征，怎么划分，怎么剪枝，介绍信息增益</li><li>K-Means 聚类这种方法一定会收敛嘛？如果不收敛，怎么办？</li><li>SVM 的目标函数，为什么能用拉格朗日乘子法讲原始最优化问题转化为极大极小问题，数学原理是什么</li><li>介绍SVM，其中的软间隔是什么意思？</li><li>使用线性回归的时候什么时候会需要用L2？</li><li>如果F1已经趋于平稳，如何在保持F1稳定的前提下提高precision，降低recall；</li><li>LR 为什么不用 MSE，SVM 为什么用hinge不用logloss</li><li>XGBoost 怎么解决过拟合？怎么剪枝？怎么选择特征？怎么处理缺失值？</li><li>XGBoost 的默认深度</li><li>各种决策树模型的优劣（从最简单的ID3到最后的LGB）</li><li>SVM 核函数哪些是高维空间维度已知，哪些是未知的？</li><li>LR介绍、LR对特征需要做什么特殊处理吗？类别特征、连续特征</li><li>损失函数正则项的本质是什么? </li><li>SVM 有哪些核函数？</li><li>L1 正则化为什么能使特征稀疏？</li><li>Stacking原理，还有怎么调优？</li><li>XGBoost怎么调参？用了多少棵树？</li><li>各种决策树模型的优劣（从最简单的ID3到最后的LGB）</li><li>ID3 C4.5 CART的区别</li><li>手推 SVM, GBDT, XGBoost</li><li>CRF 怎么训练的（传统+深度学习）</li><li>得到AUC的两种计算方法</li><li>树的分裂方式（id3,gini,gdbt,xgboost）</li><li>监督学习的概念？什么是随机森林，随机森林的优点？</li><li>LR和SVM区别（计算复杂度）</li><li>Adam优化器的迭代公式</li><li>SGD每步做什么，为什么能online learning</li><li>L1 L2正则化区别</li><li>PCA原理和执行步骤</li><li>特征工程知道吗？举几个特征归一化的例子</li><li>SVM为什么可以处理非线性问题</li><li>L1正则化的先验分布？</li><li>L1的不知道，L2的先验分布知道吧？</li><li>多标签分类问题怎么解决，从损失函数角度考虑</li></ul><h1 id="NN"><a href="#NN" class="headerlink" title="NN"></a>NN</h1><ul><li><a href="https://a-kali.github.io/2019/12/01/激活函数汇总/">激活函数除了Sigmoid tanh ReLU 还有什么介绍一下</a></li><li>BFE 和 Dropout的关系</li><li>Dropout是失活神经元还是失活连接</li><li>手推梯度反向传播</li><li>分类网络样本不均衡怎么办？</li><li>dropout层作用，如何实现有什么作用？</li><li>Dropout 前向和反向的处理</li><li>神经网络如果没有激活函数还能解决线性不可分问题吗？</li><li>Tensorflow的动态图和静态图有什么区别</li><li>GN，BN，LN，IN 它们的共性和特性</li><li>为什么BN有泛化能力的改善. 什么场景用什么normalization方法，效果如何.</li><li>Dropout为什么能防止过拟合？具体实现</li><li>dropout在训练和测试时不同，怎么保证测试结果稳定</li><li>如何计算神经网络的 FLOPS？</li><li>梯度下降陷入局部最优有什么解决办法</li></ul><h1 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h1><ul><li>手写灰度直方图代码</li><li>介绍一下开运算和闭运算</li><li>介绍双目相机识别目标深度的原理</li><li>单目视觉如何测量深度？</li><li>介绍常见的边缘检测算法</li><li>SIFT 特征是如何保持旋转不变性的？</li><li>如何快速判断图中有环？</li><li>介绍常见的边缘检测算子</li><li>Hough 变换原理（直线和圆检测）</li><li>为什么 Sobel 算子中间是2，两边是1</li><li>算法题：实现 OpenCV中的图像缩放，包括实现双线性插值</li><li>输入图像灰度值对模型的影响，为什么要把0-255转化成0-1？</li><li>介绍 RANSAC</li><li>介绍一阶二阶边缘检测算子一阶二阶边缘检测算子</li><li>OpenCV里面findcontour函数的原理是什么？</li><li>相机里面的标定参数有哪些？是怎么计算这些参数的？</li><li>如何求边缘，45°边缘，高斯滤波和双边滤波</li><li>代码题：手撕实现图像的resize和rotate90度</li><li>手写中值滤波</li><li>介绍一下高斯滤波，均值滤波，中值滤波</li><li>SIFT特征提取怎么做的，具备什么性质，为什么</li><li>讲一下CTC的原理</li><li>夜间拍照的多图对齐和融合</li></ul><h1 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h1><ul><li>介绍你读到的19年 Anchor-free 目标检测论文</li><li>简单介绍Fast RCNN -&gt; Faster RCNN -&gt; mask RCNN (这个真的好高频)</li><li>256×256×3 -&gt; 128×128×64的卷积，stride，padding和待优化的参数有多少</li><li>手撕 SoftNMS代码</li><li>CNN反向传播公式推导；参数共享指的是？</li><li>介绍熟悉的NAS网络</li><li>介绍目标检测中的多尺度训练/测试？</li><li>为什么 DenseNet 比 ResNet 更耗显存？</li><li>为什么深度学习中的图像分割要先编码再解码？</li><li><a href="https://a-kali.github.io/2019/09/04/Inception-v1-v4/">1×1 卷积有什么作用？</a></li><li>如何计算语义分割的 mIoU（写伪代码）</li><li>原始图片中的 RoI 如何映射到 feature map ?</li><li>PyTorch的高效convolution实现</li><li>PyTorch 不用库函数如何实现多机多卡</li><li>哪些情况用 MaxPool比AveragePool效果好？原因</li><li>介绍Anchor based 和Anchor free目标检测网络的优缺点</li><li>YOLOv3在小缺陷检测上也很好，RPN上和two-stage的有什么区别</li><li>MobileNetV2 module的参数量和FLOPs计算</li><li>CNN 的感受野受什么影响</li><li>CNN 如何保持平移方向不变性</li><li>如果分类的数据图像每一类只有几张，你会用什么方法？</li><li>RPN怎么计算 box 的实际坐标</li><li>介绍常见的 Anchor free 目标检测算法</li><li>算法题：编程实现目标检测中的 IoU 计算</li><li>公式及讲解soft attention，hard attention，multi head attention</li><li>卷积操作是线性的吗？CNN是线性的吗？为什么？（激活函数）常用的激活函数？</li><li><a href="https://a-kali.github.io/2019/09/04/Inception-v1-v4/">3×3 卷积核 与 5×5 卷积核相比的优点</a></li><li><a href="https://a-kali.github.io/2019/09/04/Inception-v1-v4/">InceptionV1~V4系列介绍，以及每一版的改进，优缺点介绍</a></li><li>CNN Maxpooling 怎么反向传播？</li><li>写出 YOLOv3 的损失函数</li><li>YOLOV1~V3系列介绍，以及每一版的改进，优缺点介绍</li><li>介绍金字塔池化，ASPP，深度可分，带孔卷积</li><li>VGG网络什么特点，用到了哪几种卷积核？</li><li>介绍 anchor-based和anchor-free两者的优缺点</li><li>PyTorch 多gpu训练机制的原理，优化器以及网络参数保存机制</li><li>讲下faster-rcnn？Faster-rcnn里面的NMS的算法原理是什么？</li><li>Mask R-CNN 如何提高mask的分辨率？</li><li>普通卷积、DW+PW卷积计算量推导</li><li>MobileNet V2中的Residual结构最先是哪个网络提出来的</li><li>CornerNet介绍，CornerPooling是怎么做的，怎么解决cornernet检测物体合并为一个框的问题</li><li><a href="https://a-kali.github.io/2019/09/04/Inception-v1-v4/">GoogLeNet中为什么采用小的卷积核？</a></li><li><a href="https://a-kali.github.io/2019/10/26/FCN论文解读/">说一下UNet的结构</a></li><li>熟悉deeplab吗，aspp是怎样的，与其他的state-of-art的模型对比，deeplab还可以做哪些改进？</li><li>retinanet的focal loss是解决的什么问题</li><li>CRF后处理的目的</li><li>介绍deeplabv3，画出backbone（串联和并联），论文中认为这两种哪种方式更好？如何避免friding efect、deeplabv3的损失函数</li></ul><h1 id="SLAM"><a href="#SLAM" class="headerlink" title="SLAM"></a>SLAM</h1><ul><li>PnP求解最少需要几个点？</li><li>ORBSLAM的哪个部分最耗时？</li><li>ORBSLAM怎么克服尺度漂移问题？</li><li>回环原理讲一下，要估计哪些量？</li><li>后端BA中，如何存在outlier一般怎么解决？</li><li>BA中，海塞矩阵的求逆有哪些可以加速的方法？</li><li>单应矩阵(homography)为什么只有8个自由度？</li><li>如何设计一个视觉+IMU+RTK+Lidar的定位系统？</li><li>对于光照明暗变化、动态场景，视觉SLAM如何去解决？</li><li>ROS中，node属于多进程，如何把两个node放在一个进程中？</li><li>ORBSLAM 后端H矩阵求解的算法复杂度是多少？如何去加速后端求解？</li><li>ORB-SLAM的初始化步骤</li><li>介绍 Bundle Adjustment</li><li>机器人学中表示旋转的方式有哪些？区别是什么？</li><li>检测圆的方法有哪些？</li><li>霍夫圆变换的原理是什么？</li><li>你知道哪些点云匹配的算法？原理是什么？</li><li>ROS里面的一些基本操作怎么实现？</li><li>怎么估计3D姿态？用什么表示姿态？</li><li>相机标定方法与流程，内外参矩阵求解</li><li>什么是闭环检测？常用的方法有哪些？你用的哪种方法？有没有创新？</li><li>解释一下Gauss-Netwon和LM算法。</li><li>熟悉Ceres优化库吗？说一下。</li><li>描述（扩展）卡尔曼滤波与粒子滤波，你自己在用卡尔曼滤波时遇到什么问题没有？</li><li>除了视觉传感，还用过其他传感吗？比如GPS，激光雷达。。。</li></ul><h1 id="反向面试"><a href="#反向面试" class="headerlink" title="反向面试"></a>反向面试</h1><p>再也不用担心面试官灵魂拷问：你有什么要问我的么？</p><p>下面列表里的问题对于参加技术面试的人来说很有用：</p><ul><li>我的日常工作是什么？</li><li>入职培训会是什么样的？</li><li>你们怎么使用源码控制系统？</li><li>团队内/团队间的交流通常是怎样的？</li><li>有标准的开发环境吗？是强制的吗？</li><li>我可以为开源项目做贡献吗？是否需要审批？</li><li>团队里面初级和高级工程师的比例是多少？</li><li>晋升流程是怎样的？要求/预期是怎样沟通的？</li><li>我入职的岗位是新增还是接替之前离职的同事？</li><li>入职之后在哪个项目组，项目是新成立还是已有的？b公司是否有技术分享交流活动？有的话，多久一次呢？</li><li>更多提问可以在 <a href="https://github.com/yifeikong/reverse-interview-zh" target="_blank" rel="noopener">https://github.com/yifeikong/reverse-interview-zh</a> 找到</li></ul><p>出了以上几种类型的题目，还常见编程算法题、C++语言细节、Python语言细节、英语题、数学题、项目、计算机网络和操作系统</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ML&quot;&gt;&lt;a href=&quot;#ML&quot; class=&quot;headerlink&quot; title=&quot;ML&quot;&gt;&lt;/a&gt;ML&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;介绍一下调参的经验&lt;/li&gt;
&lt;li&gt;Softmax的公式和伪代码&lt;/li&gt;
&lt;li&gt;分类常见的指标有什么，如何理解AUC？&lt;/
      
    
    </summary>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="语义分割" scheme="http://a-kali.github.io/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"/>
    
      <category term="神经网络" scheme="http://a-kali.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="机器学习" scheme="http://a-kali.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://a-kali.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="图像处理" scheme="http://a-kali.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="面试" scheme="http://a-kali.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="SLAM" scheme="http://a-kali.github.io/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>周志华《机器学习》</title>
    <link href="http://a-kali.github.io/2019/09/16/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B/"/>
    <id>http://a-kali.github.io/2019/09/16/周志华《机器学习》/</id>
    <published>2019-09-16T11:28:39.000Z</published>
    <updated>2019-09-18T12:36:28.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-绪论"><a href="#第-1-章-绪论" class="headerlink" title="第 1 章    绪论"></a>第 1 章    绪论</h1><h2 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h2><p>假设（hypothesis）：根据数据的潜在规律学习而得的模型。亦称为学习器。</p><p>簇（cluster）：聚类学习中的一个组。</p><p>泛化（generalization）：学得模型适用于新样本的能力。</p><h2 id="1-3-假设空间"><a href="#1-3-假设空间" class="headerlink" title="1.3 假设空间"></a>1.3 假设空间</h2><p>假设空间：机器学习中可能的函数构成的空间。学习的过程即是在假设空间中进行搜索的过程。</p><h1 id="第-2-章-模型评估与选择"><a href="#第-2-章-模型评估与选择" class="headerlink" title="第 2 章    模型评估与选择"></a>第 2 章    模型评估与选择</h1><h2 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2 评估方法"></a>2.2 评估方法</h2><h3 id="2-2-1-留出法"><a href="#2-2-1-留出法" class="headerlink" title="2.2.1 留出法"></a>2.2.1 留出法</h3><p><strong>留出法</strong>（hold-out）将数据集划分为两个互斥的集合，分别作为训练集和测试集。</p><h3 id="2-2-2-交叉验证法"><a href="#2-2-2-交叉验证法" class="headerlink" title="2.2.2 交叉验证法"></a>2.2.2 交叉验证法</h3><h3 id="2-2-3-自助法"><a href="#2-2-3-自助法" class="headerlink" title="2.2.3 自助法"></a>2.2.3 自助法</h3><p><strong>自助采样法</strong>（bootstrap sampling）对大小为 m 的数据集进行 m 次放回采样，采样得到的数据作为训练集，初始数据集中大约有 36.8% 的数据未被采样过，这部分数据作为测试集。</p><p>自助法在数据集较小、难以划分测试集和训练集时比较有用。但会改变原有数据集的分布，引入估计偏差。</p><h3 id="2-2-4-调参与最佳模型"><a href="#2-2-4-调参与最佳模型" class="headerlink" title="2.2.4 调参与最佳模型"></a>2.2.4 调参与最佳模型</h3><p>模型评估与选择中，用于评估模型的数据集常称为<strong>验证集</strong>。</p><h2 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3 性能度量"></a>2.3 性能度量</h2><p>性能度量：对模型泛化能力的评价标准。</p><p>均方误差（mean squared error）：$E(f;D)=\frac{1}{m} \sum^m_{i=1}(f(x_i)-y_i)^2.$ 常用于回归任务中。</p><h3 id="2-3-1-错误率与精度"><a href="#2-3-1-错误率与精度" class="headerlink" title="2.3.1 错误率与精度"></a>2.3.1 错误率与精度</h3><ul><li><strong>错误率</strong>（error rate）：分类错误的样本数占样本总数的比例</li><li><strong>精度</strong>（accuracy）：分类正确的样本数占样本总数的比例</li></ul><p>此处的评估标准仅仅是根据样本分类的正误个数进行评估，没有表现出单个样本的错误程度。</p><h3 id="2-3-2-查准率、查全率与-F1"><a href="#2-3-2-查准率、查全率与-F1" class="headerlink" title="2.3.2 查准率、查全率与 F1"></a>2.3.2 查准率、查全率与 F1</h3><p>在信息检索等应用场景中经常出现如下的需求，比如想知道“检索出的信息中有多少比例是用户感兴趣的”“用户感兴趣的信息中有多少被检索出来了”。此时用<strong>查准率</strong>（precision）和<strong>查全率</strong>（recall，也被称为召回率）更为适合此类需求。</p><p>混淆矩阵：</p><p><a href="https://imgchr.com/i/nfoRB9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/16/nfoRB9.png" alt="nfoRB9.png"></a></p><p>查准率 P 和查全率 R 分别被定义为<br>$$<br>P=\frac{TP}{TP+FP}\<br>R=\frac{TP}{TP+FN}<br>$$<br>查全率和查准率是一对矛盾的度量。一般来说，查全率高时查准率低，查准率高时查全率低。</p><p>P-R曲线、ROC和AUC可参考<a href="https://a-kali.github.io/2019/09/03/机器学习中的评价指标/">机器学习中的评价指标</a>。</p><h3 id="2-3-4-代价敏感错误率与代价曲线"><a href="#2-3-4-代价敏感错误率与代价曲线" class="headerlink" title="2.3.4 代价敏感错误率与代价曲线"></a>2.3.4 代价敏感错误率与代价曲线</h3><p>不同类型的错误所造成的后果不同，为权衡不同类型错误所造成的不同损失，可以为错误赋予<strong>非均等代价</strong>。</p><p>在非均等代价下，我们所希望的不再是简单地最小化错误次数，而是希望最小化<strong>总体代价</strong>。以二分类为例，其代价敏感错误率为：<br>$$<br>E = \frac{1}{m}(\sum_{x_i\in D^+}I(f(x_i)\not=y_i)\times cost_{01}+\sum_{x_i\in D^-}I(f(x_i)\not=y_i)\times cost_{10})<br>$$<br>其中$I(·)$为指示函数，$cost$为错误的权重（即代价）。</p><p><strong>代价曲线</strong>可以直接反映非均等代价下学习器的期望总体代价。代价曲线的绘制很简单：ROC曲线上的每一点对应了代价平面上的一条线段，根据ROC曲线上的每一点的状态绘制一条从(0,FPR) 到 (1, FNR) 的线段，线段下的面积即表示了该条件下的期望总体代价。</p><p><img src="https://s2.ax1x.com/2019/09/18/n7Ri7j.png" alt="n7Ri7j.png"></p><h1 id="第-3-章-线性模型"><a href="#第-3-章-线性模型" class="headerlink" title="第 3 章    线性模型"></a>第 3 章    线性模型</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第-1-章-绪论&quot;&gt;&lt;a href=&quot;#第-1-章-绪论&quot; class=&quot;headerlink&quot; title=&quot;第 1 章    绪论&quot;&gt;&lt;/a&gt;第 1 章    绪论&lt;/h1&gt;&lt;h2 id=&quot;1-2-基本术语&quot;&gt;&lt;a href=&quot;#1-2-基本术语&quot; class
      
    
    </summary>
    
      <category term="机器学习" scheme="http://a-kali.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://a-kali.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Inception v1-v4 论文解读</title>
    <link href="http://a-kali.github.io/2019/09/04/Inception-v1-v4/"/>
    <id>http://a-kali.github.io/2019/09/04/Inception-v1-v4/</id>
    <published>2019-09-04T09:57:36.000Z</published>
    <updated>2019-12-02T09:38:59.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Inception-V1"><a href="#Inception-V1" class="headerlink" title="Inception V1"></a>Inception V1</h1><p>论文地址：<a href="https://arxiv.org/pdf/1409.4842v1.pdf" target="_blank" rel="noopener">Going deeper with convolutions</a></p><h2 id="动机与深层思考"><a href="#动机与深层思考" class="headerlink" title="动机与深层思考"></a>动机与深层思考</h2><p>直接提升神经网络性能的方法是提升网络的深度和宽度。然而，更深的网络意味着其参数的大幅增加，从而导致计算量爆炸。因此，作者希望能在计算资源消耗恒定不变的条件下，提升网络性能。</p><p>降低计算资源消耗的一个方法是使用<a href="https://baike.baidu.com/item/稀疏连接/22764619?fr=aladdin" target="_blank" rel="noopener">稀疏连接</a>结构，但不均匀的稀疏数值运算在当前适合密集运算的硬件条件下运行十分低效。作者希望将稀疏连接结构运用于卷积层，并以此解决稀疏连接在密集运算条件下效率低下的问题。于是Inception便应运而生。</p><h2 id="架构细节"><a href="#架构细节" class="headerlink" title="架构细节"></a>架构细节</h2><p> <img src="https://s2.ax1x.com/2019/10/04/uDtGDI.png" alt="uDtGDI.png"></p><p>作者希望“找到最优的局部结构，并在空间上重复它”，如上的Inception模块便是作者找到的最优局部结构。该结构有<strong>四个通道，同时使用了1×1、3×3、5×5的卷积核</strong>。作者表示“卷积核的大小并没有什么特殊含义，其便利性大于必要性”，在padding=0，1，2的时候特征图大小相同，<strong>方便对齐</strong>。</p><p>随着网路层数的加深，其特征图的抽象程度变高，空间集中程度下降。这意味着5×5卷积核占比应逐渐增加。然而在具有大量滤波器的卷积层，5×5卷积核运算量太大。这催生了对Inception的第二个改进：在计算量要求较多的地方<strong>使用1×1卷积核进行降维</strong>。于是便诞生了完整版的Inception V1模块：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDB4kn.png" alt="uDB4kn.png"></p><h2 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h2><p>GoogLeNet是一个大量使用了Inception模块堆叠的一个神经网络，其结构如下（图太大了，这里就不放完整图片了）：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDrWin.png" alt="#uDrWin.png"></p><p>值得一提的是，考虑到深层网络的梯度消失问题（当时还没出现批归一化和残差结构），GoogLeNet使用了在网络的中间隐藏层使用了<strong>辅助分类器</strong>（auxiliary classifiers），其训练时给出的分类结果的损失的以0.3的权重加到总损失上，以在一定程度上解决梯度消失问题。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li><p>很多文章中都有提到，Inception结构使用不同大小的卷积核能够适应不同尺度的特征。虽然并没有在原论文中看见相关阐述，但我觉得有点道理。论文中提到Inception在目标检测任务中有更出色的效果，这很可能与其能适应不同尺度特征有关。</p><p><img src="https://s2.ax1x.com/2019/10/04/uDo1Ds.png" alt="如图，图中三只狗狗所占图片区域大小不同"></p></li><li><p>作者并没有在原论文中提到Inception结构起作用的原因，但我认为Inception结构和ResNet的残差结构有异曲同工之妙（虽然ResNet的诞生在GoogLeNet之后）。残差结构能让神经网络自己通过调整参数来选择是否趋近于恒等映射，而Inception能让神经网络自己选择卷积核大小（3×3、5×5 convolutions），或是将这层作为全连接（1×1 convolutions，Inception结构最左边的那个1×1卷积核作用相当于全连接），抑或是池化（3×3 Max Pooling）。</p></li></ul><h1 id="Inception-V2-amp-V3"><a href="#Inception-V2-amp-V3" class="headerlink" title="Inception V2&amp;V3"></a>Inception V2&amp;V3</h1><p>论文链接：<a href="https://arxiv.org/abs/1512.00567" target="_blank" rel="noopener">Rethinking the Inception Architecture for Computer Vision</a></p><h2 id="通用设计准则"><a href="#通用设计准则" class="headerlink" title="通用设计准则"></a>通用设计准则</h2><p>该论文提出了4个神经网络的设计准则，并根据这些准则改进Inception。以下列出关键的两条：</p><ul><li>避免一次性大幅压缩（大尺寸卷积、池化等）特征图的尺寸，否则会造成<strong>表征性瓶颈</strong>，特征图中的信息会大量损失。</li><li>高维度的特征更容易局部处理，解耦更多的特征，加速网络训练。</li></ul><h2 id="分解（Factorization）大尺寸卷积"><a href="#分解（Factorization）大尺寸卷积" class="headerlink" title="分解（Factorization）大尺寸卷积"></a>分解（Factorization）大尺寸卷积</h2><p>作者提出，大尺寸卷积的计算量和它的尺寸是不成比例的。于是<strong>将原来的5×5卷积改成了两个3×3卷积</strong>：</p><p><img src="https://s2.ax1x.com/2019/10/07/uRSdMD.png" alt="uRSdMD.png"></p><p>然后减少了28%的计算量。</p><h2 id="分解为不对称的卷积"><a href="#分解为不对称的卷积" class="headerlink" title="分解为不对称的卷积"></a>分解为不对称的卷积</h2><p>然后作者想把3×3分解成更小的卷积……尝试了分解成两个2×2，节省了11%的计算量。然后尝试了分解成1×3和3×1，节省了33%计算量。于是便多出了如下两类不对称分解的Inception模块：</p><p><img src="https://s2.ax1x.com/2019/10/07/uRCVIA.png" alt="uRCVIA.png"></p><p>左图模块特性：</p><ul><li>在网络的浅层表现不佳，但在网络的中层有较好的效果。</li><li>由于比原版模块增加了一层非线性层，提高了模型的表达能力。</li></ul><p>右图模块特性：</p><ul><li>能够维持特征的高维度，符合上述通用设计准则的第二条。</li></ul><h2 id="减少特征图尺寸"><a href="#减少特征图尺寸" class="headerlink" title="减少特征图尺寸"></a>减少特征图尺寸</h2><p>当网络需要将一个尺寸为 2d×2d、维度为 k 的特征图转换为一个尺寸为 d×d、维度为 2k 的特征图时，问题就来了：如果先减小尺寸，那么将会损失大量信息，造成准则第一条中的表征性瓶颈；如果先增大维度，那么计算量将翻3倍。如何高效地减小特征图尺寸呢？作者提出了以下结构：</p><p><img src="https://s2.ax1x.com/2019/10/07/uRkv3n.png" alt="uRkv3n.png"></p><p>该结构在增加特征维度、减少特征图尺寸的同时避免了表征性瓶颈和计算量过大的问题。</p><h2 id="Inception-v2"><a href="#Inception-v2" class="headerlink" title="Inception-v2"></a>Inception-v2</h2><p><img src="https://s2.ax1x.com/2019/10/07/uRVxgA.png" alt="uRVxgA.png"></p><p>其中使用了三种Inception模块（图中红框处），包括3个普通分解模块和5个不对称分解堆叠模块以及2个不对称分解扩展模块。值得一提的是原网络中的7×7卷积被分解成了3个3×3卷积。</p><h2 id="Inception-v3"><a href="#Inception-v3" class="headerlink" title="Inception-v3"></a>Inception-v3</h2><p>在论文的后续中，作者对Inception v2进行了如下改进：</p><ul><li>使用RMSProp优化器</li><li>辅助分类器使用了BatchNorm</li><li>标签平滑（正则化）</li></ul><h1 id="Inception-V4-amp-Inception-Resnet"><a href="#Inception-V4-amp-Inception-Resnet" class="headerlink" title="Inception V4 &amp; Inception-Resnet"></a>Inception V4 &amp; Inception-Resnet</h1><p>论文地址：<a href="https://arxiv.org/pdf/1602.07261.pdf" target="_blank" rel="noopener">Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>随着 ResNet 网络的出现及其在主流数据集上的良好表现，作者想将残差结构引入到 Inception 网络中，看看网络是否会有更好的表现；同时注意到Inception-v3的部分结构有不必要的复杂性，于是尝试在不引入残差结构的情况下改进原本的Inception结构，并将改进后的Inception结构命名为Inception-v4。</p><p>我感觉这篇论文的知识量不大，整篇论文一半都是图，看看了解下就行。</p><h2 id="Inception-v4"><a href="#Inception-v4" class="headerlink" title="Inception-v4"></a>Inception-v4</h2><p><img src="https://s2.ax1x.com/2019/10/08/uhaJjs.png" alt="uhaJjs.png"></p><p>图中是v4使用的三个Inception模块。分别命名为Inception-A、Inception-B、Inception-C。除了所有的池化层都使用了<strong>Avg Pooling</strong>以外，没有什么特别的变动。另外网络整体结构也发生了一些改变，这里直接用网图了：</p><p><img src="https://img-blog.csdnimg.cn/2018102913400312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6YzE1ODA2,size_27,color_FFFFFF,t_70" alt></p><h2 id="Inception-Resnet"><a href="#Inception-Resnet" class="headerlink" title="Inception-Resnet"></a>Inception-Resnet</h2><p><a href="https://imgchr.com/i/uhwGmn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/08/uhwGmn.md.png" alt="uhwGmn.md.png"></a></p><p><img src="https://img-blog.csdnimg.cn/20181029135504384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6YzE1ODA2,size_27,color_FFFFFF,t_70" alt></p><p>上图是 Inception-Resnet-v1 的模块和结构， Inception-Resnet-v2只是在v1的基础上使用了Inception-v4的stem结构。</p><h1 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h1><p><strong>Q：GoogLeNet中为什么采用小的卷积核？</strong></p><p>A：多个小卷积核的叠加能起到和大卷积核一样的效果，并且运算量更小。</p><p><strong>Q：3×3 卷积核 与 5×5 卷积核相比的优点</strong></p><p>A：速度更快，性能更好</p><p><strong>Q：InceptionV1~V4系列介绍，以及每一版的改进，优缺点介绍</strong></p><p>A：v1提出Inception模块，提供四个通道，方便模型自己在全连接、小卷积、大卷积、池化之间做出选择；v2提出分解卷积和不对称分解卷积，降低了运算量，以及提出了解决表征性瓶颈的结构；v3在v2的基础上修改了优化器、添加了辅助分类器的BN和标签平滑；v4提出了几种新的Inception模块，取得了更好的性能。</p><p><strong>Q：1×1 卷积有什么作用？</strong></p><p>A：跨通道信息整合（参考Inception模块和Res模块）；降维减少计算量（参考Inception模块）</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]<a href="http://baijiahao.baidu.com/s?id=1601882944953788623&wfr=spider&for=pc" target="_blank" rel="noopener">一文概览Inception家族的「奋斗史」</a></p><p>[2]<a href="https://blog.csdn.net/zzc15806/article/details/83504130" target="_blank" rel="noopener">【深度学习】GoogLeNet系列解读 —— Inception v4</a></p><p>[3]<a href="https://blog.csdn.net/weixin_39953502/article/details/80966046" target="_blank" rel="noopener">inception-v1,v2,v3,v4—-论文笔记</a></p><p>以及文中所述的论文链接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Inception-V1&quot;&gt;&lt;a href=&quot;#Inception-V1&quot; class=&quot;headerlink&quot; title=&quot;Inception V1&quot;&gt;&lt;/a&gt;Inception V1&lt;/h1&gt;&lt;p&gt;论文地址：&lt;a href=&quot;https://arxiv.or
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="论文解读" scheme="http://a-kali.github.io/tags/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="神经网络" scheme="http://a-kali.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Inception" scheme="http://a-kali.github.io/tags/Inception/"/>
    
  </entry>
  
  <entry>
    <title>线性回归与逻辑回归</title>
    <link href="http://a-kali.github.io/2019/09/03/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%B8%8E%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>http://a-kali.github.io/2019/09/03/线性回归与逻辑回归/</id>
    <published>2019-09-03T13:21:16.000Z</published>
    <updated>2019-11-26T15:12:40.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p>​    <strong>线性回归</strong>通常是解决连续数值预测问题，利用数理统计的回归分析，来确定变量之间的相互依赖关系，线性方程通常表示如下:<br>$$<br>h_\theta(x)=\theta_0 +\theta_1x_1+\theta_2x_2+……+\theta_nx_n=θ^Tx<br>$$</p><p>线性回归梯度下降方程：<br>$$<br>\theta_j:=\theta_j-\alpha \frac{\partial J(\theta_j)}{\partial \theta_j}<br>$$<br>其中 $J(\theta_j)$ 为损失函数，$\alpha$为学习率。</p><h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p>​    <strong>逻辑（Logistic，又称 Sigmoid）回归</strong>常用于解决二分类问题，用于估算某种事物的可能性。Sigmoid 函数公式如下：<br>$$<br>g(z)=\frac{1}{1+e^{-z}}<br>$$<br>该函数的值域为 (0, 1)，其值的意义为输入特征被分到 1 类的概率。逻辑回归的本质是在线性回归之后加了一层函数映射。将线性回归方程带入到逻辑回归方程中，得到逻辑回归表达式：<br>$$<br>h_\theta(x) = g(\theta^Tx)=\frac{1}{1+e^{-\theta^Tx}}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性回归&quot;&gt;&lt;a href=&quot;#线性回归&quot; class=&quot;headerlink&quot; title=&quot;线性回归&quot;&gt;&lt;/a&gt;线性回归&lt;/h1&gt;&lt;p&gt;​    &lt;strong&gt;线性回归&lt;/strong&gt;通常是解决连续数值预测问题，利用数理统计的回归分析，来确定变量之间的相互
      
    
    </summary>
    
      <category term="机器学习" scheme="http://a-kali.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://a-kali.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性回归" scheme="http://a-kali.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
      <category term="逻辑回归" scheme="http://a-kali.github.io/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>机器学习中的评价指标</title>
    <link href="http://a-kali.github.io/2019/09/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    <id>http://a-kali.github.io/2019/09/03/机器学习中的评价指标/</id>
    <published>2019-09-03T08:52:16.000Z</published>
    <updated>2019-09-18T07:01:26.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><table><thead><tr><th align="center">-</th><th align="center">Positive Predictions</th><th align="center">Negative Predictions</th></tr></thead><tbody><tr><td align="center">Positive Label</td><td align="center">TP (True Positive)</td><td align="center">FN</td></tr><tr><td align="center">Negative Label</td><td align="center">FP</td><td align="center">TN</td></tr></tbody></table><h2 id="Accuracy（ACC，准确率）"><a href="#Accuracy（ACC，准确率）" class="headerlink" title="Accuracy（ACC，准确率）"></a>Accuracy（ACC，准确率）</h2><p>$$<br>ACC= \frac{TP+TN}{FP+FN+TP+TN}=\frac{预测正确的样本数}{总样本数}<br>$$</p><h2 id="Precision（PRE，精度、查准率）"><a href="#Precision（PRE，精度、查准率）" class="headerlink" title="Precision（PRE，精度、查准率）"></a>Precision（PRE，精度、查准率）</h2><p>$$<br>PRE=\frac{TP}{TP+FP}=\frac{预测正确的正样本数}{所有预测为正的样本数}<br>$$</p><h2 id="True-Positive-Rate（TPR，召回率、查全率）"><a href="#True-Positive-Rate（TPR，召回率、查全率）" class="headerlink" title="True Positive Rate（TPR，召回率、查全率）"></a>True Positive Rate（TPR，召回率、查全率）</h2><p>$$<br>TPR=\frac{TP}{TP+FN}= \frac{预测正确的正样本数}{总正样本数}<br>$$</p><h2 id="False-Positive-Rate（FPR，误报率）"><a href="#False-Positive-Rate（FPR，误报率）" class="headerlink" title="False Positive Rate（FPR，误报率）"></a>False Positive Rate（FPR，误报率）</h2><p>$$<br>FPR=\frac{FP}{TN+FP}=\frac{预测为正的负样本数}{总负样本数}<br>$$</p><h2 id="False-Negative-Rate（FNR，漏报率）"><a href="#False-Negative-Rate（FNR，漏报率）" class="headerlink" title="False Negative Rate（FNR，漏报率）"></a>False Negative Rate（FNR，漏报率）</h2><p>$$<br>FNR=\frac{FN}{TN+FN}=\frac{预测为负的正样本数}{预测成负样本的总数量}<br>$$</p><h1 id="评估曲线"><a href="#评估曲线" class="headerlink" title="评估曲线"></a>评估曲线</h1><h2 id="PR-曲线"><a href="#PR-曲线" class="headerlink" title="PR 曲线"></a>PR 曲线</h2><p>精度又名查准率, 关心的是 “查出的所有正例中, 哪些正例是查对的”<br>召回率又名查全率, 关心的是 “对于所有的正例, 正确查出了多少个”</p><p>这二者是一对矛盾的度量, 因为我们很容易知道:</p><ul><li>如果我们希望查准率高, 那么可以认为是 “只有当十成把握认为其是正例时, 才将其挑出”。</li><li>而如果我们希望召回率高, 那么可以认为是 “宁错杀一百, 不放过一个”. 查准率和查全率的曲线又叫 PR 曲线, 如下图所示：</li></ul><p><img src="https://s2.ax1x.com/2019/09/03/nkRp6J.jpg" alt="nkRp6J.jpg"></p><p>通常情况下, 如果一个学习器的 PR 曲线被另一个学习器 <strong>完全包住</strong>. 那么我们就认为后者的性能优于前者. 当二者存在交叉时, 我们可以通过四种方式来确定学习器的优劣：</p><ol><li><p>计算 PR 曲线与横纵坐标轴围成的面积, 面积越大越好；</p></li><li><p>利用平衡点 (BEP, 查准率=查全率), BEP 越大越好；</p></li><li><p>利用$F_\beta$度量, 当 $\beta&lt;1$ 时， 查准率(精度)权重更大, 当$\beta&gt;1$时， 查全率(召回率)权重更大。$F_\beta$的计算公式来自于加权调和平均数：<br>$$<br>\frac{1}{F_\beta}=\frac{1}{1+β^2}(\frac{1}{P}+\frac{β^2}{R})<br>$$<br>$$<br>F_β=\frac{(1+β^2)×P×R}{β^2×P+R}<br>$$</p></li></ol><h2 id="ROC-曲线"><a href="#ROC-曲线" class="headerlink" title="ROC 曲线"></a>ROC 曲线</h2><p>​    很多学习器是为测试样本产生一个实值或概率预测，然后将这个预测值与一个分类阈值进行比较，若大于阈值分为正例，否则分为负例，因此<strong>分类过程可以看做是选取一个合适的截断点</strong>。那么到底什么样的截断点更合适呢？ ROC 正是从这个角度来研究学习器好坏的工具。</p><p>​    ROC 曲线的纵坐标和横坐标分别是召回率和误诊率，下图为 ROC 曲线图，实际任务中会利用有限个测试样本来绘制 ROC 图，所以产生的大多不是平滑的曲线。</p><p><img src="https://s2.ax1x.com/2019/09/03/nk7o59.jpg" alt="nk7o59.jpg"></p><h3 id="绘制-ROC-曲线"><a href="#绘制-ROC-曲线" class="headerlink" title="绘制 ROC 曲线"></a>绘制 ROC 曲线</h3><p>​    假设已经得出一系列样本被划分为正类的概率，然后按照大小排序，下图是一个示例，图中共有20个测试样本，”Class” 一栏表示每个测试样本真正的标签（p表示正样本，n表示负样本），”Score” 表示每个测试样本属于正样本的概率。</p><p><img src="https://s2.ax1x.com/2019/09/03/nkLzOP.jpg" alt="nkLzOP.jpg"></p><p>​    接下来，我们从高到低，依次将“Score”值作为阈值threshold，当测试样本属于正样本的概率大于或等于这个threshold时，我们认为它为正样本，否则为负样本。举例来说，对于图中的第4个样本，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。每次选取一个不同的threshold，我们就可以得到一组FPR和TPR，即ROC曲线上的一点。这样一来，我们一共得到了20组FPR和TPR的值，将它们画在ROC曲线的结果如下图：</p><p><img src="https://s2.ax1x.com/2019/09/03/nkOQkF.jpg" alt="nkOQkF.jpg"></p><h3 id="ROC-曲线的意义"><a href="#ROC-曲线的意义" class="headerlink" title="ROC 曲线的意义"></a>ROC 曲线的意义</h3><p>​    有助于选择最佳的阈值。ROC曲线越靠近左上角，模型的准确性就越高。最靠近左上角的ROC曲线上的点是分类错误最少的最好阈值，其假正例和假反例总数最少。</p><h2 id="AUC-的含义及计算"><a href="#AUC-的含义及计算" class="headerlink" title="AUC 的含义及计算"></a>AUC 的含义及计算</h2><p>​    <strong>AUC</strong>（Area Under Curve）被定义为ROC曲线下与坐标轴围成的面积，显然这个面积的数值不会大于1。又由于ROC曲线一般都处于y=x这条直线的上方，所以AUC的取值范围在0.5和1之间。</p><p>​    在进行学习器的比较时，若一个学习器的ROC曲线被另一个学习器的曲线完全“包住”，则可断言后者的性能优于前者；若两个学习器的ROC曲线发生交叉，则难以一般性的断言两者孰优孰劣。此时如果一定要进行比较，则比较合理的判断依据是比较AUC，AUC大的学习器通常性能更好。</p><h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h1><p><a href="https://hellozhaozheng.github.io/z_post/计算机视觉-计算机视觉知识点总结/" target="_blank" rel="noopener">计算机视觉知识总结</a></p><p><a href="https://baike.baidu.com/item/AUC/19282953?fr=aladdin" target="_blank" rel="noopener">AUC 百度百科</a></p><p><a href="https://zdkswd.github.io/2018/11/20/精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线/" target="_blank" rel="noopener">精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线</a></p><p><a href="https://blog.csdn.net/Libo_Learner/article/details/83615715" target="_blank" rel="noopener">机器学习笔记~F-score beta衡量precision和recall之间重要性</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;混淆矩阵&quot;&gt;&lt;a href=&quot;#混淆矩阵&quot; class=&quot;headerlink&quot; title=&quot;混淆矩阵&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="机器学习" scheme="http://a-kali.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://a-kali.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="评价指标" scheme="http://a-kali.github.io/tags/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>Kaggle 比赛记录之 Severstal: Steel Defect Detection</title>
    <link href="http://a-kali.github.io/2019/09/02/Severstal-Steel-Defect-Detection-%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"/>
    <id>http://a-kali.github.io/2019/09/02/Severstal-Steel-Defect-Detection-比赛记录/</id>
    <published>2019-09-02T02:18:54.000Z</published>
    <updated>2019-10-16T15:08:55.522Z</updated>
    
    <content type="html"><![CDATA[<p>​    看论文看腻了，正好抽空看看隔壁的 Severstal 比赛。希望能吸取一点之前的教训，在这场比赛上好好发挥。</p><h1 id="比赛概览"><a href="#比赛概览" class="headerlink" title="比赛概览"></a>比赛概览</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>​    大概就是一家中国企业为了提高扁钢的生产质量而希望使用计算机视觉来检测扁钢损坏而发布的一场比赛。</p><h2 id="成绩评价指标"><a href="#成绩评价指标" class="headerlink" title="成绩评价指标"></a>成绩评价指标</h2><p>​    <strong>Dice系数：</strong><br>$$<br>Dice(s_1, s_2)=2*\frac{s_1\cap s_2}{s_1+ s_2}<br>$$<br>用于比较两字符串的相似度，大概就是两字符串相同字符的个数乘2比上长度之和。这里应该是用来比较 RLE 编码的相似度。</p><p>​    提交的数据的三分之一用于公榜展示，剩下的三分之二作为最终成绩。这意味着可能比赛结束成绩就出来了。</p><h2 id="比赛时间"><a href="#比赛时间" class="headerlink" title="比赛时间"></a>比赛时间</h2><ul><li><p>2019.10.17 加入比赛、数据公开和组队的截止日期。</p></li><li><p>2019.10.24 提交最终成绩。</p></li><li><p>2019.11.10 高效奖争夺最终提交。（该比赛的前 50 可以进入高效奖的争夺）</p></li></ul><h2 id="这是一个-Kernels-only-比赛"><a href="#这是一个-Kernels-only-比赛" class="headerlink" title="这是一个 Kernels-only 比赛"></a>这是一个 Kernels-only 比赛</h2><p>​    最终的提交文件必须在 kernel 上生成，比赛者需要上传模型并在 kernel 上进行最后的测试。并需要满足以下条件：</p><ul><li>单 GPU 情况下运行时间不超过<strong>一小时</strong>。</li><li>断网。</li></ul><h1 id="比赛数据"><a href="#比赛数据" class="headerlink" title="比赛数据"></a>比赛数据</h1><p>​    训练图集、测试图集、训练样本数据和提交样本。每张图占4行csv，分别表示其4种损坏的RLE码。</p><h1 id="EDA"><a href="#EDA" class="headerlink" title="EDA"></a>EDA</h1><p>在做EDA之前先说说自己对数据的想法：</p><ul><li>既然每个样本有 4 种损坏类型，那是不是每种损坏可以单独用一个模型来训练。</li><li>扁钢损坏率似乎不大，这意味着大多数扁钢或许只有1-2种损坏。</li></ul><p>以上有待EDA考究。</p><p>让我们来找一篇<a href="https://www.kaggle.com/go1dfish/clear-mask-visualization-and-simple-eda" target="_blank" rel="noopener">点赞数最多的 EDA</a> 瞅一瞅，得出以下信息：</p><ul><li>训练样本数为 12568，其中有损坏的样本数为 5902，接近一半</li><li>测试样本数为1801</li><li>图片长宽为 (1600, 256)</li><li>四类损坏的数量：{1: 897, 2: 247, 3: 5150, 4: 801}，可见绝大部分损坏都包含第三类损坏</li><li>每个样本具有损坏的种类：{0: 5902, 1: 6239, 2: 425, 3: 2}</li><li>第一类损坏呈密集斑点（猜想）和小矩形状</li><li>第二类损坏呈长条矩形状，似乎是刮损裂纹。竖直长度通常大于横向长度，一张图只有少数损坏。常伴生第一类损坏。</li><li>第三类损坏常呈现大块状，边缘较直，出现概率很高</li><li>第四类损坏扁钢有明显不规则突起，形状十分不规则，常伴生第三类损坏</li></ul><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ul><li>那个网状的钢是什么？有没有其他形状的？</li><li>有没有哪些易于被混淆的损坏和普通纹路？如果有可以进行可视化来找出原因。</li><li>根据类型比例来设定阈值</li><li>统计各类损坏的密集程度、长宽最大值和最小值以及比例、mask size</li><li>统计两类损坏之间有没有伴生现象</li><li>不同的类型可以使用不同的minsize和阈值</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    看论文看腻了，正好抽空看看隔壁的 Severstal 比赛。希望能吸取一点之前的教训，在这场比赛上好好发挥。&lt;/p&gt;
&lt;h1 id=&quot;比赛概览&quot;&gt;&lt;a href=&quot;#比赛概览&quot; class=&quot;headerlink&quot; title=&quot;比赛概览&quot;&gt;&lt;/a&gt;比赛概览&lt;/h
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="计算机视觉" scheme="http://a-kali.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="语义分割" scheme="http://a-kali.github.io/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"/>
    
      <category term="Kaggle" scheme="http://a-kali.github.io/tags/Kaggle/"/>
    
  </entry>
  
</feed>
